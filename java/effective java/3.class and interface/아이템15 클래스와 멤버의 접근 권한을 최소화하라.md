## 클래스의 멤버의 접근 권한을 최소화하라

* 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨서 구현과 API 를 깔끔하게 분리한다
    * API 를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다
* 정보 은닉(캡슐화) 장점
    1. 여러 컴포넌트를 병렬로 개발할 수 있기 때문에 시스템 개발 속도를 높인다
    2. 각 컴포넌트 별로 빠르게 디버깅을 할 수 있고, 컴포넌트 교체로 쉽게 변경할 수 있기 때문에 시스템 관리 비용을 낮출 수 있다
    3. 완성된 시스템을 프로파일링하여 최적화할 컴포넌트를 정하고, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화하는 방식으로 성능 최적화에 도움을 준다
    4. 소프트웨어 재사용성이 높다
    5. 컴포넌트별로 동작을 검증할 수 있기 때문에 큰 시스템을 제작하는 난이도를 낮춘다
* 접근 제한자를 활용하여 정보 은닉을 할 수 있으며, 모든 클래스와 멤버의 접근성을 가능한 좁히는 것이 좋다
    * 접근 제어 메커니즘은 클래스/인터페이스/멤버의 접근 제한자를 이용하여 적용할 수 있다

### 접근 제한자를 이용한 정보 은닉

* 톱레벨 클래스와 인터페이스의 접근제한자는 package-private 과 public 만 허용된다
    * 패키지 외부에서 쓸 이유가 없다면 package-private 을 선언해야 한다
    * public 으로 선언하면, API 가 되므로 하위 호환을 위해 영원히 관리해줘야 한다
* 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static 으로 중첩시키는 형태로도 정보은닉을 할 수 있다
    * 이러한 중첩 클래스는 해당 클래스의 상위인, package-private 에서만 접근할 수 있게 된다
* 필드/메서드/중첩 클래스/중첩 인터페이스가 가질 수 있는 접근 수준
    * private: 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다
    * package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있으며, 접근 제한자를 명시하지 않았을 때 적용된다
        * 인터페이스는 접근 제한자를 명시하지 않았을 때 public 이 된다
    * protected: 해당 멤버를 선언한 클래스와 하위 클래스에서 접근이 가능하다
    * public: 모든 곳에서 접근이 가능하다

#### 접근 제한자를 활용

* 클래스의 공개 API 를 확인한 후, 그 외의 모든 멤버는 private 으로 만든다
* 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private 으로 변경한다
    * 권한을 풀어주는 일이 반복된다면, 컴포넌트를 분해해야 할지 고민이 필요하다
    * private/package-private 는 보통 공개 API 에 영향을 주지 않는다
* public 클래스에서는 멤버 접근 수준을 package-private -> protected 로 변경하면, 해당 멤버에 접근할 수 있는 대상 범위가 넓어진다
    * public 클래스의 protected 멤버는 공개 API 이므로 영원히 지원되어야 한다
    * 또한 내부 동작 방식을 API 문서에 적어 사용자에게 공개해야 할 수도 있다
    * 따라서 protected 멤버의 수는 적을수록 좋다

#### 접근 제한자의 제약

* 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다
* 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있다는 리스코프 치환 원칙을 지키기 위해 필요하다
* 이 제약을 어기면 하위 클래스를 컴파일할 떄 컴파일 오류가 발생한다
* 클래스가 인터페이스를 궇녀하는 경우는 해당 규칙의 특별한 예이며, 인터페이스가 정의한 모든 메서드를 public 으로 선언해야 한다
* 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려는 시도를 하지만, 적당한 수준까지 넓혀도 괜찮다
    * private -> package-private 까지는 괜찮으나 그 이상은 안된다
    * 테스트만을 위해 접근 제한자를 공개 API 로 만들면 안되고, 이렇게 해야 할 필요가 없다

#### 접근 제한자의 제한

* public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다
* 가변 객체를 참조하거나 final 이 아닌 인스턴스 필드를 public 으로 선언하면, 값을 제한할 힘을 잃게 되고, 이는 불변식을 보장할 수 없게 된다는 의미가 된다
* 또한, public 가변 필드는 스레드에 안전하지 않다
* 하지만 클래스가 표현하는 추상 개념을 외부에서 참조할 상수로써 존재한다면, public static final 필드로 공개해도 좋다
* 길이가 0 이 아닌 배열은 모두 변경이 가능하므로 클래스에서 public static final 배열 필드를 두거나, 해당 필드를 반환하는 접근자 메서드를 제공해서는 안된다
    1. 해당 값을 private 으로 변경하고, 같은 값을 제공용으로 public static final `Collections.unmodifiableList` 로 제공할 수 있다
    2. 해당 값을 private 으로 변경하고, 복사본을 반환하는 public 메서드를 추가할 수 있다 (방어적 복사 - `targetList.clone()`)
    
#### 모듈 시스템

* Java 9 에서 모듈 시스템 개념이 도입되면서 두 가지 암묵적 접근 수준이 추가되었다
    * public/protected 와 같은 접근 수준을 가지지만, 모듈에 한정된다는 특이한 점이 존재한다
* 패키지가 클래스들의 묶음이면, 모듈은 패키지들의 묶음이다
* 모듈은 자신에 속한 패키지 중 공개(export) 할 것들을 관례상 moduleinfo.java 파일에 선언한다
* protected 또는 public 멤버라도 해당 패키지를 공개하지 않았다면, 모듈 외부에서 접근할 수 없다
    * 모듈 안에서 exports 로 선언하였는지 여부에 영향을 받지 않는다
* 모듈을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다
* 모듈은 접근 보호 방식 추가 외에도 여러 면에서 자바 프로그래밍에 영향을 주지만, 제대로 누리기 위해서는 해야할 일이 많다
    1. 패키지들을 모듈 단위로 묶고, 모듈 선언에 패키지들의 모든 의존성을 명시
    2. 소스 트리를 재배치
    3. 모듈 안으로부터 일반 패키지로의 모든 접근에 특별한 조취를 추가
    
## 정리

* 프로그램 요소의 접근성은 가능한 최소한으로 하라
* 필요한 것만 골라 최소한의 public API 를 설계해야 한다
* public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다
    * public static final 필드가 참조하는 객체가 불변인지 확인이 필요하다
