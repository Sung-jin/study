## 필요없는 검사 예외 사용은 피하라

* 결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다
    * 이는 검사 예외를 남발하면 오히려 코드가 지저분해지고 사용하기 불편한 API 가 될 수 있음을 의미한다
    * 또한, 호출하는 코드에서 catch 로 처리하거나 더 바깥으로 던져서 문제를 전파해야 하는 등의 번거로움이 추가된다
    * 이러한 검사 예외는 스트림 안에서 직접 사용할 수 없다
* 따라서 의미있는 조치를 취할 수 있는 경우라면 사용해도 좋지만, 그게 아니라면 비검사 예외를 사용하는게 좋다

```java
try {
    ...
} catch (CheckedException e) {
    throw new AssertionError();
}

try {
    ...
} catch (CheckedException e) {
    e.printStackTrace();
    System.exit(1);
}
```

* 위와 같이 검사 예외를 별다른 처리하지 않고 catch 로 활용만 할 경우에는 비검사 예외가 훨씬 낫다

### 검사 예외 회피하기

* 검사 예외를 회피하기 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다
    * 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다
    * 단, 이는 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없는 단점이 존재한다
* 예외를 사용하면 구체적인 예외 타입과 그 타입이 젝오하는 메서드들을 활용하여 부가 정보를 제공할 수 있다
* 검사 예외를 던지는 메서드를 2 개로 쪼개서 비검사 예외로 변경할 수 있다

```java
try {
    obj.action(args);
} catch (CheckedException e) {
    ...
}
// 위의 코드는 다음과 같이
if (obj.actionPermitted(args)) {
    ...
} else {
    // 에외 상황일 때
}
```

* 위와 같이 검사 예외를 던지는 메서드를 2 개로 쪼개서 비검사 예외로 변경할 수 있으며, 적용할 수만 있다면 쓰기 편한 API 를 제공할 수 있다
    * 이러한 방식을 통해 더 유연한 구조를 얻을 수 있다
* 하지만 이는 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 적절하지 않은 리펙토링이다
    * 두 메서드간에 호출 시점에 따라 상태가 다를 수 있기 때문이다

## 정리   

* 꼭 필요한 경우에는 검사 예외를 통해 프로그램의 안전성을 높일 수 있으나, 남용하면 사용하기 고통스러운 API 가 만들어진다
* API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지고, 복구가 가능하고 하길 원한다면 우선 optional 을 활용하는 것도 고려해야 한다
    * 이러한 optional 로만 상황 처리하기 충분한 정보를 제공할 수 없을 때만 검사 예외를 던져야 한다
