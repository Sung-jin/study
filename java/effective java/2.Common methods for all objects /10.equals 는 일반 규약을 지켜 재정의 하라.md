## equals 는 일반 규약을 지켜 재정의하라

* equals 메서드 재정의는 쉬워보이나 잘못 정의하면 문제가 발생할 가능성이 높다
    * 문제를 회피하는 가장 쉬운 길은 재정의하지 않는 방법이다
    * 재정의하지 않으면 클래스의 인스턴스는 오직 자기 자신과만 같게 된다
* 아래와 같은 상황에 해당한다면 재정의하지 않는 것이 최선이다
    1. 각 인스턴스가 본질적으로 고유한 경우
        * 값을 표현하는게 아닌 동작하는 개체를 표현하는 클래스가 여기에 해당한다
        * `Thread` 가 좋은 예이며, Object 의 equals 메서드는 이러한 클래스에 딱 맞게 구현되어 있다
    2. 인스턴스의 논리적 동치성(logical equality) 을 검사할 일이 없는 경우
        * 정규식의 `Pattern` 은 equals 를 재정의해서 두 `Pattern` 인스턴스가 같은 정규표현식을 나타내는지 논리적 동치성을 검사하는 방법도 있다
        * 하지만 설계자는 클라이언트가 이 방식을 원하지 않거나 필요하지 않다고 느낄 수 있으며, 이때는 기본 equals 만으로 해결된다
    3. 상위 클래스에서 재정의한 equals 가 하위 클래스에도 딱 들어맞는 경우
        * `Set` 구현체는 `AbstractSet` 이 구현한 equals 를 상속받아 쓰고, `List` 는 `AbstractList`, `Map` 은 `AbstractMap` 으로부터 상속받아 사용한다
    4. 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없는 경우

### equals 를 재정의해야 하는 경우

* 객체 식별성(두 객체가 물리적으로 같은가)이 아닌 논리적 동치성을 확인해야 하며, 상위 클래스의 equals 가 논리적 동치성을 비교하도록 재정의되어 있지 않은 경우이다
* 주로 값 클래스들이 해당한다
    * 값 클래스는 Integer, String 과 같이 값을 표현하는 클래스를 말한다
    * 논리적 동치성을 확인하도록 재정의하면, 해당 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응하며, `Map`/`Set` 의 원소로 사용할 수 있게 된다
* 값 클래스이지만, 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 싱글톤이라면 equals 를 재정의하지 않아도 된다

### equals 메서드 재정의시 지켜야할 일반 규약

1. 반사성(reflexivity): null 이 아닌 모든 참조 값 x 에 대해 `x.equals(x)` 는 true 이다
    * 객체는 자기 자신과 같아야 한다는 의미이다
    * 해당 규약을 어기면 컬렉션에서 존재하는 객체로 contains 메소드를 호출하면 false 가 리턴된다
2. 대칭성(symmetry): null 이 아닌 모든 참조 값 x/y 에 대해 `x.equals(y)` 가 true 이면 `y.equals(x)` 도 true 이어야 한다
    * 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 의미이다
```java
public final class CaseInsensitiveString {
    private final String s;
    
    public CaseInsensitiveString(String s) {
        this.s = Object.requireNonNull(s);
    }
    
    @Override
    public boolean equals(Object o) {
        ...
        if (o instanceof String) {
            return s.equalsIgnoreCase((string) o);
        }
        ...
    }
}

CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish";

cls.equals(s); // true
s.equals(cis); // false

List<CaseInsensitiveString> list = new ArrayLuist<>();
list.add(cis);
list.contains(s);
// 이는 jdk 버전 등과 같은 요건으로 어떻게 동작할지 예상할 수 없다

----------------------------------------------------------------

@Override
public boolean equals(Object o) {
    // Point 클래스의 equals
    ...
    Point p = (Point) o;
    return p.x == x && p.y == y;
}

@Override
public boolean equals(Object o) {
    // ColorPoint 의 equals
    if (!(o instanceof ColorPoint)) return false;
    return super.equals(0) && ((ColorPoint) o).color == color;
    // 이는 Point 를 ColorPoint 와 비교한 결과와 그 두개를 바꿔서 비교한 결과가 다를 수 있다
    // Point 의 equals 는 색상을 무시하고 ColorPoint 의 equals 는 입력 매개변수의 클래스 종류가 다르기 때문에 매번 false 를 반환한다
}

Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED);

p.equals(cp); // true
cp.equals(p); // false
```
3. 추이성(transitivity): null 이 아닌 모든 참조 값 x/y/z 에 대해 `x.equals(y)` 가 true 이고 `y.equals(z)` 도 true 이면 `x.equals(z)` 는 true 이어야 한다
    * 첫번째 객체와 두번째 객체가 같고, 두번째 객체와 세번째 객체가 같다면, 첫번째와 세번째 객체는 같아야 한다
    * 추이성이 지켜지지 않으면 무한 재귀에 빠질 위험성이 존재한다
```java
public class Point {
    private final int x;
    private final int y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public boolean equals(Object o) {
        ...
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}

public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }
    
    // equals 를 재정의하지 않으면 상속한 equals 가 동작하게 된다
    // 이는 색상 정보에 대해서는 무시하고 equals 가 동작하게 된다
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point)) return false;
        if (!(o instanceof ColorPoint)) return o.equals(this);
        
        return super.equals(o) && ((ColorPoint) o).color == color;
        // 대칭성은 지켜주지만 추이성은 깨진다
    }
}

ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColoΩPoint(1, 2, Color.BLUE);

p1.equals(p2); // true
p2.equals(p3); // true
p1.equals(p3); // false

/**
 * Point 의 또다른 하위 클래스를 생성하고, equals 도 같은 방식으로 구현한다음
 * 서로 다른 Point 의 하위 클래스끼리 equals 를 호출하면 StackOverflowError 가 발생한다
 * 
 * 이러한 문제는 모든 객체 지향 언어의 동치관계에서 발생하는 근본적인 문제이다
 * 객체 지향적 추상화의 이점을 포기하지 않는 이상 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다
 */
```
4. 일관성(consistency): null 이 아닌 모든 참조 값 x/y/z 에 대해 `x.equals(y)` 를 반복해서 호출하면 항상 같은 결과가 나와야 한다
5. null 아님: null 이 아닌 모든 참조 값 x 에 대해 `x.equals(null)` 은 false 이다

* 컬렉션 클래스들을 포함하여 수많은 클래스는 전달받은 객체가 equals 규약을 지킨다고 가정하고 동작한다
* Object 명세에서 말하는 동치관계란 집합을 서로 같은 원소들로 이루어진 부분집합으로 나누는 연산이다
    * 이러한 부분집합을 동치류(equivalence class) 라고 한다
* equals 메서드가 쓸모있기 위해서는 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다
