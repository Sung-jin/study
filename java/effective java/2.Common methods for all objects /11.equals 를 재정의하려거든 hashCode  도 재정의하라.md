## equals 를 재정의하려거든 hashCode 도 재정의하라

* equals 를 재정의한 클랮스 모두 hashCode 도 재정의해야 한다
    * 이를 어기면 hashCode 일반 규약을 어기게 되면서 해당 클래스의 인스턴스를 HashMap 이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제가 발생한다
* Object 명세에 있는 규약
    1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드를 몇번 호출하더라도 일관되게 같은 값을 반환해야 한다
        * 애플리케이션을 다시 실행할때 값이 달라지는건 상관이 없다
    2. equals 가 두 객체를 같다고 판단한다면 두 객체의 hashCode 는 똑같은 값을 반환해야 한다
        * hashCode 재정의를 잘못한 경우 가장 문제가 되는 부분이다
        * 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다
        * equals 는 물리적으로 다른 두 객체를 논리적으로 같다고 할 수 있지만, Object 의 기본 hashCode 는 이 둘이 전혀 다르다고 판단하면서 규약과 달리 서로 다른 값을 반환한다
    3. equals 가 두 객체를 다르다고 판단하더라도 hashCode 가 서로 다른 값을 반환할 필요는 없다
        * 단, 다른 객체에 대해서 다른 값을 반환해야 해시 테이블의 성능이 좋아진다

### equals 를 재정의하고 hashCode 를 재정의 하지 않았을 때

```java
// equals 를 재정의한 PhoneNumber 클래스
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(070, 867, 5309), "제니");
m.get(new PhoneNumber(070, 867, 5309));
// 제니가 반환되어야 할 것으로 예상되지만, null 이 반환된다
// 2개의 PhoneNumber 인스턴스가 사용되었고, 각 인스턴스는 hashCode 를 재정의하지 않았기 떄문에 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하면서
// HashMap 의 get 이 예상과 다르게 null 이 반환하게 된 것이다
// 이는 HashMap 은 해시코드가 다른 엔트리끼리 동치성 비교를 시도조차 하지 않도록 최적화 되어 있기 때문에 이러한 현상이 발생한 것이다
```

* 위와 같은 문제는 hashCode 메서드만 작성하면 해결된다

### hashCode 작성

```java
@Override
public int hashCode() {
    return 42;
}
// 위 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법하다
// 하지만 모든 객체에 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결 리스트처럼 동작한다
// 결과적으로 평균 수행 시간이 O(1) 인 해시테이블이 O(n) 으로 느려지게 된다
```

* 좋은 hashCode 메서드라면 서로 다른 인스턴스에 대해 다른 해시코드를 반환해야 한다
* 이상적인 hashCode 는 서로 다른 인스턴스끼리 32 비트 정수 범위에 균일하게 분배해야 한다
* 이상을 완벽히 실현하기 어렵지만 다음과 같이 비슷하게 구현을 할 수 있다
    1. int 변수 result 를 선언한 후 값 c 로 초기화한다
        * c 는 해당 객체의 첫번째 핵심 필드를 아래 방식으로 계산한 해시코드이다
        * 핵심 필드란 equals 비교에 사용되는 필드를 말한다
    2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다
        * 해당 필드의 해시코드 c 를 계산한다
            a. 기본 타입 필드라면 `Type.hashCode(f)` 를 수행한다
                * `Type` 은 해당 기본 타입의 박싱 클래스이다
            b. 참조 타입 필드면서 해당 클래스의 equals 메서드가 이 필드의 equals 를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode 를 재귀적으로 호출한다
                * 계산이 복잡해질 것 같으면 해당 필드의 표준형을 만들어 표준형의 hashCode 를 호출한다
                * 필드의 값이 null 이면 0 을 사용한다
            c. 필드가 배열이라면 핵심 원소 각각을 별도 필드처럼 다룬다
                * 위의 규칙을 재귀적으로 적용하면서 핵심 원소의 해시코드를 계산한 다음에 `result = 31 * result + c` 방식으로 갱신한다
                * 배열에 핵심 원소가 하나도 없다면 단순한 상수를 사용한다
                * 모든 원소가 핵심 원소라면 Arrays.hashCode 를 사용한다
        * 위 단계를 완료한 후 계산한 해시코드 c 로 result 를 `result = 31 * result + c` 로 갱신한 후 반환한다
* hashCode 를 구현하였다면 해당 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 생각해보고, 검증할 단위 테스트를 작성해야 한다
* 파생 필드 해시코드 계싼에서 제외해도 되고, equals 비교에 사용되지 않는 필드는 반드시 제외해야 한다
    * equals 비교에 사용되지 않는 필드를 hashCode 계산시 사용된다면, hashCode 2번째 규약을 어길 가능성이 생긴다
* `31 * result` 는 필드를 곱하는 순서에 따라 result 값이 달라지게 한다
    * 클래스에 비슷한 필드가 여러개일 때 해시 효과를 크게 높여준다
    * 예를들어 String 의 hashCode 를 곱셈 없이 구현한다면 모든 아나그램의 해시코드가 같아지게 된다
    * 31 로 정한 이유는 31 이 홀수이면서 소수이기 때문이다
        * 해당 숫자가 짝수이고 오버플로가 발생한다면 정보를 잃게 된다
            * 2를 곱하는 것은 시프트 연산과 같은 결과를 내기 때문이다
            * 31 을 이용하는 이유는 명확하지 않지만, 곱셈을 시프트 연산과 뺄셈으로 대체해 최적화할 수 있다 (31 * i = (i << 5) - 1)

```java
// 위와 같은 요건으로 적용된 PhoneNumber 클래스의 hashCode
@Override
public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

* 위의 hashCode 는 해당 인스턴스의 핵심 필드만 사용하여 간단한 계싼을 수행하면서, 비결정적 요소는 전혀 없으므로 동치인 인스턴스들은 같은 해시코드를 가지게 된다
* 위의 해시 함수 제작 요령은 최첨단은 아니지만 충분히 훌륭하며, 해시 충돌이 더 적은 방법을 사용해야만 한다면 com.google.common.hash.Hashing 을 참고할 수 있다

### Object.hash(...)

* Object 클래슨느 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메서드인 hash 를 제공한다
    * 이 메소드를 사용하면 PhoneNumber 에서 구현된 코드와 빗스한 수준의 hashCode 가 만들어진다
    * 하지만 입력 인수를 담기 위한 배열이 만들어지고 입력 중 기본 타입이 있다면 박싱과 언박싱도 거치기 때문에 느리다
    * 성능이 민감하지 않은 경우에 사용하면 좋다
    
```java
@Override
public int hashCode() {
    return Object.hash(lineNum, prefix, areaCode);
}
```

### 해시코드 캐싱

* 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱하는 방식을 고려해야 한다
    * 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다
    * hashCode 가 불릴때 지연 초기화하는 전략을 사용할 수 있으나, 이는 스레드를 고려하여 안전하게 구현해야 한다
    
```java
private int hashCode = 0;

@Override
public int hashCode() {
    int result = hashCode;
    if (hashCode == 0) {
        ...
    }
    return result;
}
```

### 해시 코드 작성시 주의점

* 성능을 높이기 위해 해시코드 계산시 핵심 필드를 생략해서는 안된다
    * 속도는 빨라질 수 있지만, 해시 품질이 나빠져 해시테이블의 성능이 심각하게 떨어질 수 있다
    * 특히 어떤 필드는 특정 영역에 몰린 인스턴스들의 해시코드를 넓은 범위로 고르게 퍼트려주는 효과가 있는데, 이러한 필드를 계산시 생략한다면 수많은 인스턴스들이 몇개의 해시코드로 집중되어 해시테이블의 성능이 나빠지는 상황이 발생할 수 있다
        * 이는 Java 2 전의 String 은 최대 16개의 문자만으로 해시코드를 계산하였고, URL 과 같이 계층적인 이름을 대량으로 사용한다면 심각한 문제를 가지게 된다
* hashCode 가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말아야 한다
    * 클라이언트가 해당 값에 의지하지 않게 되고, 추후 계산 방식을 변경할 수 있다
    * String, Integer 등 자바 라이브러리의 많은 클래스에서 hashCode 메서드가 반환하는 정확한 값을 알려주고 있으며, 향후 릴리즈에서 해시 기능을 개선할 여지도 없애버렸다
        * 자세한 규칙을 고표하지 않았다면, 해시 기능에서 결함을 발견했거나 더 나은 해시 방식을 알아낸 경우 다음 릴리즈에서 수정할 수 있다

## 정리

* equals 를 재정의할 때는 hashCode 도 반드시 재정의해야 한다
    * 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다
* 재정의한 hashCode 는 Object API 문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현되어야 한다
    * 이는 반본적이고 귀찮으며, 이도 AutoValue 프레임워크를 사용한다면 편하게 어노테이션만으로 쉽게 자동으로 구현될 수 있다
    * IDE 도 이러니 기능을 일부 제공한다
