## 박싱된 기본 타입보다는 기본 타입을 사용하라

* Java 의 기본 타입은 int, double, boolean, String, List 등이 존재한다
    * String, List 의 경우 참조 타입이다
* `int: Integer`/`double: Double`/`boolean: Boolean` 과 같은 기본 타입에 대응되는 참조 타입이 모두 존재한다
* 오토 박싱/언박싱 때문에 두 타입을 크게 구분하지 않고 사용이 가능하나, 둘 사이에는 분명한 차이점이 존재한다

### 기본 타입과 박싱된 기본 타입의 차이점

1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값과 식별성이란 속성을 가진다
    * 이는 값은 같더라도 인스턴스마다 다르다고 식별이 가능하다
2. 기본 타입의 값은 언제나 유효하지만 박싱된 기본 타입은 null 을 가질 수 있다
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다

### 박싱된 기본 타입이 가질 수 있는 문제점

```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

* 리스트에 중복이 존재해도 위 코드는 문제없이 동작하지만 `naturalOrder.compare(new Integer(42), new Integer(42))` 의 결과는 0 이 아닌 1 이 출력된ㄸ다
    1. `i < j` 는 잘 동작하지만 i 와 j 가 참조하는 오토박싱된 Integer 인스턴스는 기본 타이으로 변환된다
    2. 다음으로 `i == j` 에 대한 검사가 동작하지만, 이때 두 객체 참조의 식별성을 검사하게 된다
    3. 따라서 값이 같더라도 i 와 j 가 서로 다른 Integer 인스턴스라면 비교 결과는 false 가 되면서 1 이 반환된다

```java
static Integer i;

if (i == 42) println("hello world!");
```

* 위 코드는 i 의 초기값이 null 이고, 42 라는 int 와 비교하기 위해 언박싱되면서 NPE 예외가 발생한다

```java
Long sum = 0;
for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;
}
println(sum);
```

* 위 코드는 예외가 발생하지는 않지만, sum 이 Long 으로 박싱된 타입으로 선언되고, 해당 값을 더할때는 long 을 더하면서 Integer.MAX_VALUE 만큼 언박싱/오토 박싱이 발생하면서 성능상에 문제가 발생하게 된다

### 박싱된 기본 타입이 사용되어야 하는 곳

1. 컬렉션의 원소, 키 값으로 사용할 때
    * 컬렉션은 기본 타입을 담을 수 없으므로 박싱된 기본 타입을 써야만 한다
    * 이는 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다는 의미이다
    * 자바에서 타입 매개변수로 기본 타입을 지원하지 않기 때문이다
2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다

## 정리

* 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용해야 한다
* 기본 타입을 간단하고 빠르며, 박싱된 기본 타입을 사용해야 한다면 주의를 기울여야 한다
* 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 위험까지는 없애주지 않는걸 명심하고 사용해야 한다
* 박싱된 기본 타입을 `==` 연산자로 비교한다면 식별성 비교가 이루어지며, 이는 일반적으로 원하는 형태의 비교가 아니므로 유의해야 한다
* 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 발생하며, 언박싱 과정에서 NPE 예외가 발생할 수 있음을 유의해야 한다
* 기본 타입을 박싱ㄹ하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다
