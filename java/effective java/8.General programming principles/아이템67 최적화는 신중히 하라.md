## 최적화는 신중히 하라

* 최적화는 좋은 결과보다 해로운 결과로 이어지기 쉽고, 섣불리 진행할수록 더 좋지못한 결과가 발생할 수 있다
    * 잘못된 최적화는 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시킨다
* 즉, 빠른 프로그램보다 좋은 프로그램을 작성해야 한다
    * 이는 성능 때문에 견고한 구조를 희생하지 않아야 함을 의미한다
    * 좋은 프로그램이지만 성능이 나오지 않는다면, 아키텍처 자체가 최적화할 수 있는 길을 안내할 수도 있다
    * 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다
    * 따라서 시스템의 나머지에 영향으 ㄹ주지 않고도 각 요소를 다시 설계할 수 있다
* 이는 프로그램을 완성하기 전까지 성능 문제를 무시하지 말라는 의미가 아니다
    * 구현상의 문제는 나중에 최적화하여 해결할 수 있다
    * 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능하다
* 완성된 설계의 기본 틀을 변경하면 유지보수하거나 개선하기 어려운 구조의 시스템이 만들어지기 쉬워진다
* 결론적으로 설계 단계에서 성능을 반드시 염두에 달아두어야 한다

### 성능을 제한하는 설계를 피하라

* 완성 후 변경하기 어려운 설계 요소는 컴포넌트끼리, 외부 시스템과의 소통 방식이다
    * API, 네트워크 프로토콜, 영구 저장용 데이터 포멧 등
* 이러한 요소들은 완성후에 변경하기 어려우며, 시스템 성능을 심각하게 제한할 수도 있다

### API 를 설계할 때는 성능에 주는 영향을 고려하라

* public 타입을 가변으로 만들면 불필요한 방어적 복사를 수없이 유발할 수 있다
* 컴포지션으로 해결할 수 있음에도 상속 방식으로 구현하면, 상위 클래스에 영원히 종속되며 그 성능 제약까지도 물려받게 된다
* 인터페이스가 있으나, 구현 타입을 사용하는 것 역시 좋지 않다

### 성능을 위해 API 를 왜곡하지 않아야 한다

* API 를 왜곡하도록 만든 성능 문제는 해당 플랫폼이나 다음 버전에서 사라질 수 있지만 왜곡된 API 와 이를 지원하는 데에는 문제가 계속 발생할 수 있다
* 즉, 명확한 구조를 갖춘 프로그램을 완성하였으나 성능에 만족하지 못한 경우에 최적화를 고려해볼 차례가 된다

### 각각의 최적화 시도 전후로 성능을 측정하라

* 시도한 최적화 기법이 성능을 눈에 띄게 높이지 못하는 경우가 많고, 더 나빠지는 경우도 존재한다
* 이러한 주요 원인은 프로그램에서 시간을 잡아먹는 부분을 추측하기가 어렵기 때문이다
* 느리다고 예상한 부분이 사실은 성능에 별다른 영향을 주지 않는 곳일 수 있으며, 이때는 시간만 낭비하게 된다

### 프로파일링 도구

* 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 준다
* 이러한 도구는 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공하여, 집중할 곳을 알려준다
* 시스템이 커질수록 프로파일러는 더 많은 도움이 된다

### 자바 성능 모델

* 자바의 성능 모델은 정교하지 않을뿐더러 구현 시스템, 릴리즈, 프로세서마다 차이가 있다
* 여러 가지 자바 플랫폼이나 여러 하드웨어 플랫폼에서 구동한다면 최적화의 효과를 각각에서 측정해야 한다

## 정리

* 빠른 프로그램을 작성하려 안달하지 말고, 좋은 프로개름을 작성하려 해야 한다
    * 좋은 프로그램을 작성하면 성능은 따라오게 마련이다
* 하지만 설계할 때는 성능을 염두에 두어야 한다
* 시스템 구현을 완료하였다면, 성능 측정도 필요하다
    * 충분히 빠르다면 괜찮고,문제가 잇따면 프로파이럴를 사용하여 문제의 원인이 되는 지점을 찾아 최적화를 수행해야 한다
* 사용한 알고리즘에 따라 성능은 크게 차이가 날 수 있으므로 적절하고 좋은 알고리즘을 선택해야 한다
    * 이러한 최적화를 진행한 이후에도 반드시 성능 측정을 진행해야 한다
