## 매개변수가 유효한지 검사하라

* 메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다
* 이러한 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다
    * 이는 오류는 가능한 빨리 잡아야 한다는 일반 원칙의 한 사례이다
    * 오류를 발생한 즉시 발견하지 못하면 해당 오류를 감지하기 어려워지고, 오류를 감지하더라도 발생 지점을 찾기 어려워지게 된다
* 메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다

### 매개변수 검사를 하지 않으면

* 메서드 실행 도중 모호한 예외를 던지며 실패할 수 있다
    * 더 최악의 경우 잘못된 수행이 완료되고, 잘못된 결과를 반환할 수도 있다
    * 즉, 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다는 의미이다
    
### 매개변수 예외의 문서화

* public/protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다
* 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다
* 이러한 간단한 방법으로 API 사용자가 제약을 지킬 가능성을 크게 높일 수 있다
  
### 매개변수 체크의 여러 좋은 메서드

* null 체크를 반복적으로 할 필요 없이, Java 7 에 추가된 `java.util.Objects.requireNonNull` 메서드를 통해 검사를 수행하는 것도 좋은 방버이다
    * null 일 경우 메세지를 지정할 수 있으며, 반복적인 null 체크가 아닌 의미있는 메서드로 활용이 가능하고, 반환값은 무시하고 순수한 null 체크 용도로 사용도 가능하다
* Objects 의 `checkFromIndexSize`/`checkFromToIndex`/`checkIndex` 등과 같은 매서드와 배열 전용 메서드가 존재하지만, 여러 제약이 있다
* `assert`(단언문) 을 이용하여 매개변수의 유효성을 검증할 수도 있다
    * 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다
    * 단언문은 실패하면 `AssertionError` 를 던진다
    * 런타임에 아무런 효과도, 아무런 성능 저하도 없다 (java 실행 시 -ea 또는 --enableassertions 플래그를 설정하면 런타임 영향을 준다)
    
### 메서드 몸체 실행 전 매개변수 유효성 검사의 예외사항

* 유효성 검사 비용이 지나치게 크거나 실용적이지 않은 경우
* 계산 과정에서 암묵적으로 검사가 수행될 경우
* 단, 암묵적 유효성 검사에 너무 의존한다면 실패 원자성을 해칠 수 있다

### 주의사항

* 계산 과정에서 필요한 유효성 검사가 이루어졌지만 실패했을 때 잘못된 예외를 던지기도 한다
    * 이는 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다는 의미이다
    * 이러한 경우에는 예외 번역 관용구를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다
    
## 정리

* '무조건 매개변수에 제약을 두는게 좋다' 의 의미가 아니다
    * 메서드는 최대한 범용적으로 설계해야 하며, 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다
    * 하지만 구현하려는 개념 자체가 특정한 제약을 내재한 경우도 드물지 않으므로 상황에 따라 적절히 선택해야 한다
* 메서드나 생성자를 작성할 떄면 해당 매개변수들에 어떠한 제약이 있을지 생각해야 한다
    * 이러한 제약들을 문서화하고 메서드 코드 시작 부분에 명시적으로 검사해야 한다
