## 불필요한 객체 생성을 피해라

* 똑같은 기능의 객체를 매번 생성하기 보다는 재사용하는 편이 좋을때가 많으며, 불변 객체는 언제든 재사용할 수 있다

```java
String s = new String("blahblah");
// 해당 문장이 실행될 때 마다 String 인스턴스가 생성되므로 쓸데없는 행위이다
// 전달한 "blahblah" 자체가 이미 생성자로 생성하려는 String 과 같다
// 이는 실행되는 횟수만큼 쓸모없는 String 인스턴스가 많이 생성이 될 수 있다

String s = "blahblah";
// 이는 인스턴스를 매번 생성하는 대신 "blahblah" 에 해당하는 하나의 String 인스턴스를 사용한다
// 해당 방식을 사용한다면 같은 가상머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드는 같은 객체를 재사용함을 보장된다
```

* 생성자 대신 정적 팩토리 메서드를 제공하는 불변 클래스에서 정적 팩토리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다
    * `Boolean(String)` -> `Boolean.valueOf(String)`
* 결론적으로 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩토리 메서드는 전혀 그렇지 않다
    * 불변 객체뿐 아니라 가변 객체도 사용중에 변경되지 않는다면 재사용할 수 있다

### 생성 비용이 비싼 객체의 캐싱

* 생성 비용이 비싼 객체는 반복해서 필요하다면 캐싱하여 재사용 하는 것이 좋다
    * 하지만 생성하는 객체가 비싼 객체인지 매번 명확히 알 수는 없다
    * 이러한 생성 비용이 비싼 예중에 대표적으로 정규 표현식용 `Pattenr` 메서드가 존재한다
    
```java
static boolean isMatchBySomething(String s) {
    return s.matches("...");
}
// matches 내부에서 만드는 정규표현식용 Pattern 인스턴스는 한번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다
// Pattern 은 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높다

public class Something {
    private static final Pattern SOMETHING_REGEX = Pattern.compile("...");
    // 위와 같이 생성비용이 높은 Pattern 객체를 클래스 초기화 과정에서 직접 생성하여 캐싱하고, 메서드를 호출할 때 마다 해당 객체를 재사용할 수 있다
    
    static boolean isMatchBySomething(String s) {
        return SOMETHING_REGEX.matcher(s).matches();
    }   
}
```

* 위와 같이 캐싱을 하면 성능개선 뿐 아니라 코드도 명확해진다
    * 하지만, `Something` 클래스가 초기화가 된 후 한번도 `SOMETHING_REGEX` 가 호출되지 않는다면 쓸데없이 초기화가 된다
    * 이는 지연 초기화로 불필요한 초기화를 없앨 수 있으나, 코드를 복잡하게 만드는 것에 비해 크게 개선되지 않을때가 많아서 권장하지 않는다
    
### 어뎁터뷰

* 객체가 불변이라면 재사용해도 안전하지만, 덜 명확하거나 직관에 반대되는 상황이 존재한다
* 어뎁터는 실제 작업은 뒷단 객체에 위임하고 자신은 제 2의 인터페이스 역할을 해주는 객체이다
    * 뒷단 객체 외에는 관리할 상태가 없으므로 뒷단 객체 하나당 어뎁터 하나씩만 만들면 충분하다
* 예를들어 `Map` 인터페이스의 `KeySet` 메서드는 `Map` 객체 안의 키 전부를 담은 `Set` 뷰를 반환한다
    * `KeySet` 을 호출할 때마다 새로운 Set 인스턴스가 만들어지지 않을 수 있다
    * 이는 반환한 객체 중 하나를 수정하면 다른 모든 객체가 따라서 변경되는데, 이는 모두 똑같은 Map 인스턴스를 대변하기 때문이다
    * 따라서 `KeySet` 은 뷰 객체를 여러개 만들어도 상관은 없으나, 그럴 필요도 이득도 없다
* `auto boxing` 의 경우도 불필요한 객체를 만들어내는 또 다른 예이다
    * 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸때 자동으로 상호 변환해주는 기술이다
    * 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다
    * 의미상으로는 별다를 것이 없으나 성능에서는 그렇지 않다
    * 즉, 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의해야 한다
    
```java
private static long sum() {
    Long sum = 0L;
    // 위와 같이 Long 으로 선언하여 불필요한 Long 인스턴스가 2^31 개가 만들어진다
    // 단순히 Long -> long 으로 변경만 해도 아주 크게 성능이 좋아진다
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
        // 더해질 때 마다 Long 인스턴스가 1개씩 생성된다
    }
    
    return sum;
}
```

## 정리

* '객체 생성이 비싸니 피해야한다' 가 아니다
    * 요즘의 JVM 에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일은 크게 부담되지 않는다
* 프로그램의 명확성, 간결성, 기능을 위한 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다
* 또한, 아주 무거운 객체가 아닌 객체를 단순히 객체 생성을 피하기 위해 객체 풀을 만들 필요는 없다
    * 객체 풀을 만드는게 좋은 대표적인 예로는 DB 연결과 같은 생성 비용이 비싼 경우에는 사용해야 한다
    * 일반적으로 자체 객체 풀은 코드를 헷갈리게 만들고, 메모리 사용량을 늘리고 성능을 떨어뜨린다
* 요즘 JVM 의 가비지 컬렉터는 상당히 잘 최적화되어 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠르다
* 여담으로 '기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라' 와 '새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라' 와 대조적인 부분이 있다
    * 방어적 복사가 필요한 상황에서 객체를 재사용했을 때의 피해가 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다
