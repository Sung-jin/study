## 인스턴스화를 막으려면 private 생성자를 사용하라

* 정적 메서드와 정적 필드만 담은 클래스를 만드는 경우, 해당 클래스는 인스턴스로 만들어 사용하려고 설계한게 아니므로 생성자로 인스턴스를 만들어서는 안된다
    * 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 준다
    * 이는 `public` 으로 자동으로 생성이 되며, 사용자는 자동 생성된 것인지 구분할 수 없다
    * 추상 클래스로 만드는 것으로 인스턴스화를 막을 수 없으며, 하위 클래스를 만들어 인스턴스화하면 생성이 가능하다
    * 가장 쉽고 가장 명확하게 인스턴스화를 막는 방법은 `private` 생성자를 추가하기만 하면 된다

### private 생성자

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다
    private UtilityClass() {
        throw new AssertionError();
        // 예외의 경우 필수는 아니지만, 클래스 내부에서 인스턴스화를 하거나 리플랙션 등을 방지하기 위해서 예외를 던질 수 있다
    }
    ...
}
```

* 명시적 private 생성자이므로 클래스 바깥에서 접근이 불가능하다
* 또한 모든 생성자는 상위 클래스의 생성자를 호출하게 되어 있는데, private 으로 선언함으로써 하위 클래스가 상위 클래스의 생성자에 접근할 길이 없어지므로 상속이 불가능하게 되는 효과도 존재한다

### 사용처

* 객체 지향적으로 활용되는 방식이 아니므로 좋아보이지 않으나, 다음과 같은 형태로 쓰인다
* `java.lang.Math`/`java.util.Arrays` 와 같이 기본 타입 값이나 배열 관련 메서드들을 모아놓은 클래스
* `java.util.Collections` 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드 혹은 팩토리를 모아놓은 클래스
