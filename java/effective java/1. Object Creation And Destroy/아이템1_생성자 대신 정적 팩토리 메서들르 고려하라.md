## 생성자 대신 정적 팩토리 메서드를 고려하라

* 클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 `public` 메서드이다.
* 생성자와 별도로 정적 팩토리 메서드를 제공할 수 있다
    * 클래스의 인스턴스를 반환하는 단순한 정적 메서드이다
    * 디자인 패턴의 팩터리 메서드와 다르며, 디자인 패턴 중 이와 일치하는 패턴은 없다
    
```java
/**
 * boolean 기본 타입의 boxed class 인 Boolean 의 정적 팩토리 메서드
 * 이 메서드는 기본 타입인 boolean 을 받아 Boolean 객체 참조로 변환한다
 */
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

### 장점

1. 이름을 가진 메서드로써 어떠한 행위를 하는지 표현이 가능하다
    * 생성자의 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다
    * ex) `BigInteger(int, int, Random)` vs `BigInteger.probablePrime`
    * 하나의 시그니처로는 생성자가 하나만 생성이 가능하다
        * 메서드의 순서를 변경하는 등의 편법은 존재하지만, 이는 모든 메서드를 개발자가 명확하게 알고 있어야 하고, 실수할 여지가 충분하다
        * 작성자가 아닌 다른 개발자가 해당 코드를 읽을 때, 모든 API 명세를 확인이 필요하다
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다
    * 이를 활용하여 `불변 클래스` 는 인스턴스를 미리 생성하거나 생성한 인스턴스를 캐싱하여 불필요한 객체 생성을 피할 수 있다
    * `Boolean valueOf(boolean b)` 메서드와 같이 객체를 아예 생성하지 않을 수 있다
    * `Flyweight pattern` 이 이와 비슷한 기법이라고 할 수 있다
    * 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩토리 방식의 클래스는 언제 어느 인스턴스가 살아있을지 철저하게 통제할 수 있다
    * 인스턴스 통제를 통해 `싱글톤`/`인스턴스화 불가` 와 같은 형태로 만들수 있으며, 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다
    * 반환할 객체의 클래스를 자유롭게 선택할 수 있는 **엄청난 유연성**을 선물한다
    * 공개 API 를 구현할 떄 구현 클래스를 공개하지 않고 객체 반환이 가능하며 API 를 작게 유지할 수 있다
    * 이는 인터페이스를 정적 팩토리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이다
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다
    * 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관이 없다
    * 대표적으로 `EnumSet` 클래스는 원소의 수가 64개 이하인 경우 `long` 변수 하나로 관리하는 `RegularEnumSet` 인스턴스를, 65개 이상이면 `long` 배열로 관리하는 `JumboEnumSet` 의 인스턴스를 반환한다
5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다
    * 이러한 유연함은 서비스 제공자 프레임워크(대표적으로 JDBC)를 만드는 근간이 된다
        * 서비스 제공자 프레임워크에서의 제공자는 서비스의 구현체이다
        * 이러한 구현체들은 클라이언트에 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리해준다
        * 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어져 있다
            1. 구현체의 동작을 정의하는 서비스 인터페이스 (JDBC 에서 `Connection`)
            2. 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API (JDBC 에서 `DriverManager.registerDriver`)
            3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API (JDBC 에서 `DriverManager.getConnection`)
                * 클라이언트는 서비스 접근 API 를 사용할 떄 원하는 구현체의 조건을 명시할 수 있으며, 조건이 없으면 기본 구현체를 반환하거나 지원하는 구현체를 하나씩 돌아가며 반환한다
                * 이러한 서비스 접근 API 가 서비스 제공자 프레임워크의 `유연한 정적 팩토리` 의 실체이다
            4. 추가적으로 `서비스 제공자 인터페이스` 라는 네번째 컴포넌트가 쓰이기도 하며, 이는 서비스 인터페이스의 인스턴스를 생성하는 팩토리 객체를 설명한다
    * Java6 에서 `ServiceLoader` 라는 범용 서비스 제공자 프레임워크가 제공되어 프레임워크를 직접 만들 필요가 거의 없어졌다
    
### 단점

1. 상속을 하려면 `public`/`protected` 생성자가 필요하여 정적 팩토리 메서드만 제공하면 하위 클래스를 생성할 수 없다
    * 컬렉션 프레임워크의 유틸리티 구현 클래스와 같은 클래스들은 상속할 수 없다
    * 하지만 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들려면 이러한 제약을 지켜야 한다는 점에서 장점으로 받아들일 수 있다
2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다
    * 생성자처럼 API 설명에 명확히 드러나지 않아서 사용자는 정적 팩토리 메서드 방식 클래스를 인스턴스화할 방법을 알아야 한다
    * 이러한 부분은 API 문서와 메서드 이름을 널리 알려진 규약을 따라 짓는 등으로 문제를 완화해줘야 한다
    
#### 정적 팩토리 메서드에서 흔히 사용하는 명명 방식

* `from`: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
    * ex) `Date d = Date.from(instant);`
* `of`: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
    * ex) `Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);`
* `valueOf`: `from`/`of` 보다 더 자세한 버전
    * ex) `BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`
* `instance`/`getInstance`: 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다
    * ex) `StackWalker luke = StackWalker.getInstance(options);`
* `create`/`newInstance`: `instance` 혹은 `getInstance` 와 같으나, 매번 새로운 인스턴스를 생성해 반환함을 보장한다
    * ex) `Object newArray = Array.new/Instance(classObject, arrayLen);`
* `getType`: `getInstance` 와 같으나 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용하며, type 은 팩토리 메소드가 반환할 객체의 타입이다
    * ex) `FileStore fs = Files.getFileStore(path);`
* `newType`: `newInstance` 와 같으나 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 사용하며, type 은 팩토리 메소드가 반환할 객체의 타입이다
    * ex) `BufferedReader br = Files.newBufferedreader(path);`
* `type`: `getType` 과 `newType` 의 간결한 버전
    * ex) `List<Complaint> litany = Collections.list(legacyLitany);`
    
## 정리

* 정적 팩토리 메서드와 public 생성자는 각자의 쓰임새가 있으며, 상대적인 장단점을 이해하고 사용하는 것이 좋다
* 하지만, 정적 팩토리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치는 것이 좋다
