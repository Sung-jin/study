## 다 쓴 객체 참조를 해제하라

* c,c++ 처럼 메모리를 직접 관리하는 언어 대신 가비지 컬렉터를 가진 java 를 사용하더라도, 메모리 관리를 신경 쓰지 않으면 안된다

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    
    public Object pop() {
        if (size == 0) throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다
     */
    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size = 1);
        }
    }
}
```

* 위 코드는 문제가 없어 보이지만, 해당 스택을 사용하는 프로그램을 오래 실행하다 보면 점차 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하된다
    * 심한경우 디스크 페이징이나 OutOfMemoryError 가 발생하여 예기치 못하게 프로그램이 종료될 수 있다
* 스택이 작아질 때 꺼내진 객체들을 프로그램이 더이상 사용하지 않더라도 가비지 컬렉터가 회수하지 않는다
    * 해당 객체들의 다 쓴 참조를 여전히 가지고 있기 때문이다
    * 다 쓴 참조란 앞으로 다시 쓰지 않을 참조를 뜻하며, 위의 코드에서는 `elements` 배열의 '활성 영역' 밖의 참조들이 모두 여기에 해당한다
    * 활성 영역은 인덱스가 size 보다 작은 원소들로 구성된다
* 위와 같이 가비지 컬렉션 언어에서는 메모리 누수를 찾기가 아주 까다롭다
    * 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 해당 객체가 참조하는 모든 객체와 해당 객체들이 참조하는 모든 객체... 를 회수하지 못한다
    * 결과적으로 몇 개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고, 잠재적으로 성능에 악영향을 줄 수 있다

### 해법

* 해법은 객체를 다 사용하였을 때 `null` 로 참조 해제 처리를 하면 된다

```java
public Object pop() {
    if (size == 0) throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 객체 참조 해제
        
    return result;
}
```

* 다 쓴 객체를 `null` 처리하면 `null` 처리한 참조를 실수로 사용할 때 프로그램은 NullPointerException 을 발생하는 이점이 생긴다
    * 후처리를 못한 객체를 사용하는 것 보다 사용하기 전에 오류로 조기에 발견하는 것이 좋다
* 하지만 모든 객체를 다 쓰자마자 일일이 `null` 처리를 할 필요는 없다
    * 이는 프로그램을 필요 이상으로 지저분하게 만든다
    * 객체 참조를 `null` 처리하는 일은 예외적인 경우이여야 한다
* 다 쓴 참조를 해제하는 가장 좋은 방법은 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다
    * 변수의 범위를 최소가 되게 정의하였다면 이러한 일은 자연스럽게 발생한다

### 그래서 null 처리는 언제?

* 위의 Stack 클래스는 메모리 누수에 취약한 이유는 스택이 자기 메모리를 직접 관리하기 때문이다
* 해당 스택은 `elements` 배열로 저장소 풀을 만들어 원소들을 관리하고, 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않는다
    * 이러한 일들은 가비지 컬렉터가 알 수 없다
    * 가비지 컬렉터의 입장에서 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체이다
    * 즉, 비활성 영역의 객체가 필요없음은 프로그래머가 아는 것이며 `null` 처리를 하여 해당 객체가 더이상 쓰지 않는 것임을 가비지 컬렉터에 알려야 한다
* 결론적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다
    * 즉, 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 `null` 처리 해줘야 한다
* 캐시 역시 메모리 누스를 일으키는 주범이다
    * 객체 참조를 캐시에 넣고, 객체를 다 사용하였지만 아무런 조취가 없다면 계속 쌓이게만 된다
    * 이러한 해법은 여러가지가 존재한다
        1. 캐시 외부에서 key 를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이면 `WeakHashMap` 을 사용해서 캐시를 만들면 된다
            * 이는 다 쓴 엔트리는 즉시 자동으로 제거된다
            * 하지만 이러한 상황에서만 `WeakhashMap` 이 유리하다
        2. 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 활용할 수 있다
            * 이러한 방식일 때는 일정 주기마다 엔트리를 clear 해줘야 한다
            * 백그라운드 스레드를 활용하거나 새 엔트리를 추가할 때 부수 작업으로 수행할 수 있다
* 리스너 혹은 콜백 또한 메모리 누수의 주범이다
    * 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 추가 조치가 없는 이상 콜백은 계속 쌓이기만 한다
    * 이럴때는 콜백을 weak reference 로 저장하면 가비지 컬렉터가 즉시 수거한다
        * 예를들어 `WeakHashMap` 의 키로 저장하면 된다

## 정리

* 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 존재한다
* 이러한 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다
* 결론적으로 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다
