## 스레드보다는 실행자/태스크/스트림을 애용하라

* java.util.concurrent 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 가지고 있다

```java
ExecutorService exec = Executors.newSingleThreadExecutor();
// 위와 같이 단 한줄로 뛰어난 작업 큐를 생성할 수 있다

exec.execute(runnable);
// 이 실행자에 실행할 태스크를 넘겨서, 실행한다

exec.shutdown();
// 위와 같이 종료가 가능하다
// 위 종료가 실패하면, vm 자체가 종료되지 않을 것이다
```

### 실행자 서비스의 기능

* 특정 테스크가 완료되기를 기다린다 (`get`)
* 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다 (`invokeAny`/`invokeAll`)
* 실행자 서비스가 종료하기를 기다린다 (`awaitTermination`)
* 완료된 태스크들의 결과를 차례로 받는다 (`ExecutorCompletionService`)
* 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다 (`ScheduledThreadPoolExecutor`)

### 두개 이상의 스레드로 큐 처리

* 간단히 다른 정적 팩토리를 이용하여 다른 종류의 실행자 서비스를 생성하면 된다
* 스레드 풀의 스레드 개수는 고정할 수도 있고, 필요에 따라 늘리거나 줄어들게 설정할 수 있다
* 이러한 실행자 대부분 java.concurrent.Executors 의 정적 팩토리를 이용하여 생성이 가능하다

### 실행자 서비스 활용

* 작은 프로그램이나 가벼운 서버일 경우 `Executors.newCachedThreadPool` 은 일반적으로 좋은 선택이다
    * 이는 특별히 설정할 것은 없으며, 일반적인 용도에 적합하게 동작한다
    * 단, 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임되어 실행되고, 가용한 스레드가 없다면 새로 하나를 생성하여 무거운 서버에는 좋지 못하다
        * 이는 CPU 이용률이 100% 가 된다면, 새로운 태스크가 도착하는 족족 다른 스레드를 생성하면서 문제가 더욱 심각해지게 된다
        * 따라서 무거운 서버에는 스레드 개수를 고정한 Executors.newFixedThreadPool 을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor 를 직접 사용하는 편이 좋다
* 작업 큐를 직접 만드는 일은 하지 않아야 하며, 스레드를 직접 다루는 것도 일반적으로 하지 않아야 한다
    * 스레드를 직접 다루면 Thread 가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다
* 반면 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 불리된다

### 태스크

* 작업 단위를 나타내는 핵심 추상 개념은 태스크이다
* 태스크는 다음과 같은 것이 있다
    1. Runnable
    2. Callable (Runnable 과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다)
* 이러한 태스크를 수행하는 일반적인 메커니즘은 실행자 서비스이다
* 태스크 수행을 실행자 서비스에 맡기면 원하느 태스크 수행 정책을 선택할 수 있으며, 생각이 변경되면 언제든 변경이 가능하다
* 실행자 프레임워크가 작업 수행을 담당해준다는 것이 가장 핵심이다

### fork-join

* Java 7 이 되면서 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장되었다
* 포크-조인 태스큰튼 포크-조인 풀이라는 특별한 실행자 서비스가 실행해준다
* 포크-조인 태스크의 인스턴스는 작은 하위 태스크로 나뉠 수 있으며, ForkJoinPool 을 구성하는 스레드들이 태스크들을 처리하며 일을 먼저 끝낸 스레드는 다른 스레드의 남은 테스크를 가져와 대신 처리할 수도 있다
    * 이렇게 모든 스레드를 활용하여 CPU 를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다
* 이러한 포크-조인 태스크를 직접 작성하고 튜닝하기는 어려우나, 포크-조인을 활용하여 만든 병렬 스트림을 이용하면 적은 노력으로 이러한 이점을 얻을 수 있다
