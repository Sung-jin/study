## 지연 초기화는 신중히 사용하라

* 지연 초기화란 필드의 초기화 시점을 그 값이 처음 필요할때까지 늦추는 기법
    * 정적 필드와 인스턴스 필드 모두 사용할 수 있다
    * 지연 초기화는 주로 최적화 용도로 사용된다
    * 클래스와 인스턴스 초기화 때 발생하는 순환 문제를 해결하는 효과도 존재한다
* 이러한 지연 초기화도 필요할 때까지 하지 않는것이 좋다
* 지연 초기화는 다음과 같은 장/단점이 있다
    * 클래스 또는 인스턴스 생성 시의 초기화 비용은 줄어든다
    * 단, 지연 초기화하는 필드에 접근하는 비용은 커진다
    * 이는 지연 초기화하려는 필드들 중 결국 초기화가 이루어지는 비율에 따라, 실제 초기화에 드는 비용에 따라, 초기화된 필드를 얼마나 빈번히 호출하느냐에 따라 성능을 느려지게 할 수도 있다

### 지연 초기화가 필요한 경우

* 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면, 필드를 초기화하는 비용이 클 경우
* 이는 명시적으로 알기 어려우며, 지연 초기화 적용 전/후의 성능을 측정을 통해서만 알 수 있다

### 지연 초기화의 어려움

* 멀티스레드 환경에서 지연 초기화를 하기 까다롭다
* 지연 초기화하는 필드를 둘 이상의 스레드가 공유한다면, 어떤 형태로든 반드시 동기화를 해야만 한다
    * 이를 고려하지 않을경우 심각한 문제가 발생할 수 있다
    
### 일반적인 상황

* 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다

```java
private FieldType field = computedFieldValue();
// 일반적인 초기화
```

### synchronized 접근자 방식의 인스턴스 필드의 지연 초기화

```java
private FieldType field;

private synchronized FieldType getField() {
    if (field == null) field = computedFieldValue();
    
    return field;
}
```

* 이는 지연 초기화가 초기화 순환성을 깨뜨릴 것 같은 경우 사용한다
* 이는 가장 간단하고 명확한 대안이다

### 정적 필드 지연 초기화

* 지연 초기화 홀더 클래스 관용구를 활용한다

```java
private static class FieldHolder {
    static final FieldType field = computedFieldValue();
}

private static FieldType getField() { return FieldHolder.field; }
// getField() 가 호출되면서, FieldHolder.field 가 처음 읽히면서
// FieldHolder 클래스 초기화가 동작한다
// 이는 getField 메서드가 필드에 접근하면서 동기화를 전혀 하지 않으므로, 성능이 느려지지 않는다
// 일반적인 VM 은 오직 클래스를 초기화할 때만 필드 접근을 동기화한다
// 클래스 초기화가 끝난 후 VM 이 자동으로 동기화 코드를 제거하여, 그 다음부터는 검사/동기화 없이 필드에 접근한다
```

### 인스턴스 필드를 지연 초기화

* 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하면 된다

```java
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    // result 필드가 필요한 이유는 해당 변수가 필드가 이미 초기화된 상황에서는 그 필드를 한번만 읽도록 보장하는 역할을 한다
    // 이는 반드시 필요하지 않지만 성능을 높이고, 저수준 동시성 프로그래밍에 표준적으로 적용되는 더 우아한 방법이다
    
    if (result != null) return result;
    // 첫 번째 검사 (락 사용 x)
    
    synchronized(this) {
        if (field == null) field = computeFieldValue();
        return field;
    }
    // 두 번째 검사 (락 사용)
}
```

* 위 방식은 초기화된 필드에 접근할 때 동기화 비용을 없애준다
* 이는 필드의 값을 두 번 검사하는 방식이고, 한 번은 동기화 없이 검사하고 두 번째는 동기화하여 검사한다
    * 두 번째 검사는 필드가 아직 초기화 되지 않은 경우 검사한다
    * 따라서 초기화 되지 않았을 경우에만 동기화하여 검사한다
* 필드가 초기화된 후 동기화하지 않으므로, 해당 필드는 반드시 volatile 로 선언해야 한다
* 이러한 이중검사를 정적 필드에 적용할 수 있지만, 지연 초기화 홀더 클래스 방식이 더 낫다

#### 이중검사 변종 (단일검사 관용구)

* 초기화해도 상관없는 인스턴스 필드를 지연 초기화해야 하는 경우에는 이중검사에서 두 번째 검사를 생략할 수 있다
    * 이를 단일검사 관용구라고 한다
    
```java
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result == null) field = result = computedFieldValue();
    
    return result;
}
```

## 정리

* 이번에 소개한 초기화 기법은 기본 타입 필드와 객체 참조 필드 모두 적용이 가능하다
* 모든 스레드가 필드의 값을 다시 계산해도 상관없고, 필드의 타입이 long, double 을 제외한 다른 기본 타입일 경우, 단일검사의 필드 선언에 volatile 한정자를 없애도 된다
    * 이를 ㅈracy single-check 관용구라 불린다
    * 이는 어떤 환경에서는 필드 접근 속도를 높여주지만, 초기화가 스레드당 최대 한 번 더 이뤄질 수 있다
    * 이는 아주 이례적인 기법이며, 보통은 거의 사용되지 않는다
* 대부분의 필드는 지연시키지 말고 바로 초기화해야 한다
    * 성능 때문 또는 초기화 순환을 막기 위하여 지연 초기화를 써야만 한다면, 올바른 지연 초기화 기법을 사용해야 한다
* 인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하는게 좋다
* 반복하여 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구를 고려하는게 좋다
