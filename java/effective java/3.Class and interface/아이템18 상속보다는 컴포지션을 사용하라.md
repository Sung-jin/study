## 상속 보다는 컴포지션을 사용하라

* 상속은 클래스가 다른 클래스를 확장하는 구현 상속을 말한다
    * 인터페이스를 상속하거나 다른 인터페이스를 확장하는 인터페이스는 제외한다
* 확장할 목적으로 설계되고 문서화도 잘 된 클래스는 상속하면 코드를 재사용하는 강력한 수단이지만, 일반적인 구체 클래스를 패키지 경계를 넘어 다른 패키지의 구체 클래스를 상속하는 일은 위험하다
* 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다
    * 상위 클래스 릴리스마다 내부 구현이 달라질 수 있고, 그로인해 상속받은 하위 클래스의 코드 변경이 없지만 하위 클래스가 오작동할 가능성이 발생한다
    * 즉, 상위 클래스를 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 맞춰서 같이 수정되어야 한다
    
```java
public class InstrumentedHashSet<E> extends HashSet<E> {
    // 추가된 원소의 수
    private int addCount = 0;
    
    ...
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    
    @Override public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }
    
    ...
}
// 인스턴스화 된 후에 추가된 원소의 개수를 표현해야 하는 요구사항을 위한 클래스

InstrumentedHashSet<String> s = new InstrumentedHashSet<>();
s.addAll(List.of("A", "B", "C"));
System.out.println(s.getADdCount());
/*
3 을 예상하였으나, 6이 출력된다
이는 addAll 이 내부적으로 add 를 호출하고, add 는 InstrumentedHashSet 가 재정의한 add 를 호출하면서
결론적으로 원소 한개당 2씩 증가하는 형태가 되었다

재정의한 addAll 을 재정의한 add 를 호출하는 형태로 변경하면,
원본 클래스인 HashSet 이 내부 구현이 변경되어도 원하는 대로 동작은 가능하지만,
InstrumentedHashSet 를 다시 재정의하는 클래스가 발생하거나,
내부적으로 private 을 사용하여 해당 결과를 이용하는 경우에는 여전히 문제가 된다

또한, 다른 원소 추가 메서드가 상위에서 추가된다면,
해당 메소드로 추가한 원소의 수는 카운트에 포함이 안된다
 */
```

#### 클래스 상속의 단점 정리

* 하위 클래스는 상위 클래스의 메서드들이 내부적으로 어떻게 쓰이는지 명확하지 않다면, 예상하지 못한 형태로 동작할 수 있다
    * 또한, 내부적으로 사용하는 형태를 안다고 하더라도 추후에 변경될 가능성이 있으며, private 메서드를 참조할 경우에는 접근할 수 없다
* 특정 기능에 대해 재정의한 메서드가 존재할때, 해당 기능을 상위 메서드에서 다른 메서드를 추가한다면, 하위 메서드에서 추가된 기능이 신규 메서드에서는 동작하지 않는다

#### 클래스 상속의 제약

* 재정의한 클래스에서 메소드를 재정의 하지 않고, 신규 메서드를 작성할 경우에도 상위 메서드가 추가한 메서드의 시그니처가 같고 반환 타입이 다르다면, 해당 클래스는 컴파일이 불가능하다
    * 반환 타입마저 같다면, 사실상 해당 메서드를 재정의한 꼴이 된다
* 또한, 하위 클래스에서 신규 메서드를 생성하면, 상위 클래스이 요구하는 구약을 만족하지 못할 가능성이 크다

### 컴포지션

* 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하는 것을 말한다
    * 기존 클래스가 새로운 클래스의 구성요소로 사용된다는 뜻에서 컴포지션이라고 한다
* 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출하여 결과를 반환하면 된다
    * 이를 통해 새로운 클래스는 기존 클래스에 영향을 받지 않으며, 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다
  
```java
public class InstrumentedSet<E> extends ForwardingSet<E> {
    // 다른 Set 인스턴스를 감싸고 있으므로, 이를 래퍼 클래스라고 하고,
    // 다른 Set 에 계층 기능을 덧씌운다는 뜻에서 데코레이터 패턴이라고 한다
    private int addCount = 0;
    
    public InstrumentedSet(Set<E> s) {
        // Set 의 인터페이스를 구현하였고, Set 의 인스턴스를 인수로 받는 생성자를 하나 제공한다
        // 임으의 Set 에 계측 기능을 덧씌워 새로운 Set 으로 만드는 것이 해당 클래스의 핵심이다
        super(s);
    }
    ...
  
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    ...
}
// 래퍼 클래스 - 상속 대신 컴포지션을 활용

public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    
    public ForwardingSet(Set<E> s) { this.s = s; }
    
    ...
  
  public boolean add(E e) { return s.add(e); }
}
// 재사용할 수 있는 전달 클래스
```

* 위와 같이 구성함으로써 InstrumentedSet 은 HashSet 의 모든 기능을 정의한 Set 인터페이스를 활용하여 설계되어 견고하고 아주 유연하다
* 상속 방식은 구체 클래스 각각을 따로 확장해야 하며, 지원하고 싶은 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의해줘야 한다
* 컴포지션은 한 번만 구현해두면, 어떠한 Set 구현체라도 계측할 수 있으며, 기존 생성자들과도 함께 사용이 가능하다
* 구아바(Guava)는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현해뒀다

#### 래퍼 클래스의 단점

* 래퍼 클래스의 단점은 거의 없으나, 콜백 프레임워크와는 어울리지 않다는 점만 주의하면 된다
    * 콜백 프레임워크에서 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출 때 사용하도록 한다
    * 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르므로, 자신의 참조를 넘기고 콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다
    * 이를 SELF 문제라고 한다

#### 상속

* 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다
* 이는 클래스 B 가 클래스 A 와 `is-a` 관계일 떄만 클래스 A 를 상속해야 한다
    * 이는 B 가 A 를 상속하려고 할 때, 'B 가 정말 A 인가?' 라는 질문으로 파악할 수 있다
    * '아니다' 라는 결정이 나온다면, private 인스턴스로 두고 A 와 다른 API 를 제공해야 하는 상황이 대다수이다

##### 상속의 원칙을 위반한 클래스 예제

* 자바의 Stack 은 Vector 가 아니지만, Stack 은 Vector 를 확장하였다
* Properties 도 Hashtable 이 아니지만, 확장하였다

### 상속 vs 컴포지션

* 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다
* API 가 내부 구현에 묶이고, 그 클래스의 성능도 영원히 제한되게 된다
* 클라이언트가 노출된 내부에 직접 접근할 수 있다는 더 큰 문제점도 존재한다
* 또한, 사용자에게 혼란을 야기할 수 있다
    * Properties 의 `getProperty(key)` 는 Properties 의 메서드이며, `get(key)` 는 Properties 의 상위인 Hashtable 의 메서드이다
* 또한, 상속을 통해 상위 클래스의 불변식을 하위 클래스가 상위 클래스를 직접 수정하여 깰 수 있다는 단점이 존재한다
* 컴포지션 대신 상속을 고려할 때의 좋은 질문
    1. 확장하려는 클래스의 API 에 아무런 결함이 없는가?
    2. 결함이 있다면, 해당 결함이 하위 클래스의 API 까지 전파되어도 괜찮은가?
        * 컴포지션은 이러한 결함을 숨기는 새로운 API 를 설계할 수 있다
        * 반대로 상속은, 상위 클래스의 결함을 그대로 승계한다
  
## 정리

* 상속은 강력하지만 캡슐화를 해친다는 치명적인 단점이 존재한다
* 상속은 하위 클래스가 순수한 `is-a` 관계일 때만 사용해야 한다
    * `is-a` 이어도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려하지 않게 설계되었다면 여전히 문제가 된다
* 상속의 추약점을 피하려면 상속 대신에 컴포지션과 전달을 사용해야 한다
    * 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱 컴포지션으로 구현해야 한다
    * 래퍼 클래스는 하위 클래스보다 견고하고 강력하다
