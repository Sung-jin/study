### 단일 모델의 단점

* 주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 한다
  * 주문, 상품, 회원 등 여러 애그리거트에서 데이터를 가져와야 한다
* 조회 화면은 속도가 빠를수록 좋으며, 여러 애그리거트에서 데이터를 가져와야 할 경우 구현 방법을 고민해야 한다
  * ID 를 이용하여 애그리거트를 참조 할 경우 즉시 로딩 방식과 같은 JPA 쿼리 관련 최적화 기능을 사용할 수 없다
  * 반대로 ID 참조가 아닌 객체 직접 참조인 경우에는 반대로 지연 로딩과 즉시 로딩에 대한 고민을 해야 한다
* 이러한 고민이 발생하는 이유는 시스템의 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문이다
  * 객체 지향으로 도메인 모델을 구현하면 도메인의 상태 변경을 구현하는데 적합하지만, 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에 고려해야 할 부분이 많다
* 이러한 구현 복잡도를 낮추는 방법으로 상태 변경을 위한 모델과 조회를 위한 모델을 분리하여 구현하는 방법이 있다

### CQRS

* 시스템이 젝오하는 기능을 크게 두가지가 있다
  1. 상태 변경
  1. 상태 정보 조회
* 도메인 모델 관점에서 상태 변경 기능은 주로 하나의 애그리거트의 상태를 변경한다
* 반대로 조회 기능은 한개 이상의 애그리거트를 조합한 결과가 필요하다
* 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다
* 이러한 복잡도를 해결하기 위한 방법으로 CQRS 가 있다
  * Command Query Responsibility Segregation
  * 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴이다
  * CQRS 는 복잡한 도메인일 수록 조회와 명령 기능이 다루는 데이터 범위에 차이가 발생하여 적합하다
  * CQRS 를 적용하면 각 모델에 맞는 구현 기술을 선택할 수 있다
* CQRS 패턴을 적용하기 위해 사용해야 할 기술이 따로 존재하지 않으며, JPA 만 사용해서 명령 모델과 조회 모델을 구현도 가능하다

### 웹과 CQRS

* 일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다
* 조회 성능을 높이기 위해 쿼리 최적화와 메모리에 조회 데이터를 캐싱하거나 조회 전용 저장소를 따로 사용하는 등의 여러 방법을 사용할 수 있다
* 이러한 기법을 사용하는 것은 결과적으로 CQRS 를 적용하는 것과 같은 효과를 만든다
  * 메머리에 캐싱하는 데이터는 DB 에 저장된 데이터를 그대로 사용하는게 아닌 필요한 형태의 모양으로 변환한 데이터를 캐싱할 때 성능에 더 유리하다
  * 쿼리 최적화한다는 것도 조회 화면에 보여질 데이터를 빠르게 읽어올 수 있도록 쿼리를 작성하는 것이다
* 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하는 것이 좋다
  * 이를 통해 조회 기능 때문에 명령 모델이 복잡해지는 것을 방지할 수 있다
  * 또한 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다
  
### CQRS 장단점

* 장점
  1 .명령 모델을 구현할 때 도메인 자체에 집중할 수 있다
  1. 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는데 집중이 가능하다
  1. 조회 성능을 향상시키는데 유리하다
* 단점
  1. 구현해야 할 코드가 많아진다
    * 단일 모델을 사용할 때 발생하는 복잡함 비용과 조호 ㅣ전용 모델을 만들때 발생하는 구현 비용을 따져봐야 한다
  1. 더 많은 구현 기술이 필요하다
