## 애그리거트와 트랜잭션

* 한 주문 애그리거트에 대해 운영자는 배송 준비 상태로 변경할 때 사용자는 배송지 주소를 변경할 경우
  * 각 작업에 대해 운영자의 작업과 고객 작업은 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다
  * 같은 정보이지만 다른 객체를 가지고 각자 작업을 진행하기 때문에, 각 작업에 대해서 서로 영향 주지 못한다
  * 즉, '배송 준비중 이라는 상태에서 배송지 정보를 변경할 수 없다' 라는 제약조건은 고객 객체에 대해서는 정상적이나, 관리자에 의해 배송 상태정보는 변경되는 현상이 발생한다
  * 이는 애그리거트의 일관성이 깨지는 현상이 발생 한 것이다
* 위와 같이 이러한 문제가 발생하지 않도록 할려면 다음 두 가지 중 하나를 해야 한다
  * 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다
  * 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다
* 이러한 방식은 애그리거트 자체의 트랜잭션과 관련이 있다
  * DBMS 가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 기법이 필요하다
  * 애그리거트에 대해 상요할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 존재한다

### 선점 잠금

* 애그리거트를 먼저 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식
  * 애그리거트를 수정하고 커밋하면 잠금을 해제하고, 이 순간 다른 대기하고 있던 스레드가 애그리거트에 접근한다
  * 선점된 작업에 의해 변경된 작업은, 다음 작업에 반영되어 작업할 수 있게 된다
  * 즉, 데이터 충돌 문제를 해소할 수 있다
* 선점 잠금은 보통 DBMS 가 제공하는 행 단위 잠금을 사용해서 구현한다
  * `for update` 와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다
  * JPA 프로바이더와 DBMS 에 따라 잠금 모드의 구현이 다르다
  
#### 선점 잠금과 교착 상태

* 선점 잠금 기능을 상요할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다
  1. 스레드1 - A 애그리거트에 대한 선점 잠금
  2. 스레드2 - B 애그리거트에 대한 선점 잠금
  3. 스레드1 - B 애그리거트에 대한 선점 잠금 시도
  4. 스레드2 - A 애그리거트에 대한 선점 잠금 시도
* 위와 같이 각자의 선점 잠금과 요청으로 인해 다음 단계를 진행하지 못하는 상황이 발생할 수 있으며, 이를 교착 상태라고 한다
* 이러한 교착상태는 상대적으로 사용자의 수가 많으면 발생할 가능성이 높다
* 이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정하면 된다
  * JPA 에서는 힌트를 이용해서 설정할 수 있다
> hints.put("javax.persistence.lock.timout", 2000); 
* 이러한 힌트는 DBMS 마다 동작하지 않을 수 있다

#### 비선점 잠금

* 선점 잠금으로 모든 트랜잭션이 해결되는 것은 아니다
* 다음과 같은 상황에서 발생할 수 있다
  1. 운영자는 배송을 위해 주문 정보를 조회한다
  2. 고객이 배송지 변경을 위해 변경 폼을 요청한다
  3. 고객이 새로운 배송지를 입력하고 배송지를 변경한다
  4. 운영자가 1에서 조회 한 데이터를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다
* 4번에서 문제가 발생하는대, 이는 고객이 변경한 주소가 아닌 이전 주소를 가지고 있으므로, 이전 주소로 물품을 보내게 된다
* 이러한 문제는 선점 잠금 방식으로 해결할 수 없다
  * 이러한 문제들을 해결하는 방법으로 비선점 잠금 방식을 선택할 수 있다
* 비선점 잠금은 잠금을 해서 동시에 접근하는 것을 막는 방식이다
  * 애그리거트에 버전으로 사용할 숫자 타입의 프로퍼티를 추가해야 한다
* JPA 는 버전을 이용한 비선점 잠금 기능을 지원한다

```java
import javax.annotation.processing.SupportedSourceVersion;

public class foo {
    ...

    @Versioon
    private long version
}
```
  
* 위와 같이 설정이 되어 있다면, 해당 애그리거트의 UPDATE 쿼리를 실행할 때 비선점 잠금 쿼리를 실행한다
* 응용 서비스는 버전에 대해 알 필요 없다
* 기능을 실행하는 도중에 야그리거트를 구하고 알맞은 기능만 실행하면 된다
* 기능을 실행하는 과정에서 애그리거트의 데이터가 변경되면 JPA 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다
  * 비선점 잠금을 위한 쿼리를 실행할 떄 쿼리 실행 결과로 수정된 행의 개수가 0 이면 이미 누군가 데이터를 수정한 것으로 판단한다
  * 이때 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점에 예외가 발생한다

```java
@Entity
public class Foo {
    ...
  
    @Version
    private long version;
    // 위의 필드를 통해 해당 엔티티의 비선점 버전을 알 수 있다
}

/*
update foo set ... version = version + 1 where ... and version = 현재 객체 버전
위와 같이 버전을 where 조건에 추가함으로써, 현재 객체의 버전과 같은 버전을 찾아서 업데이트를 진행한다
버전이 맞지 않을 경우 OptimisticLockingFailureException 예외를 던진다
이렇게 쿼리 실행 결과로 수정된 행의 개수를 파악하여 후처리를 할 수 있다
 */
```

* 사용자에게 버전도 함께 전달하여, 해당 데이터를 수정할 때 사용자에게 받은 버전과 체크하여 처리할 수 있다
  * 이러한 버전 체크를 통해 버전이 맞지 않을 경우 사용자에게 적절한 메세지를 전달할 수 있다
  
#### 강제 버전 증가

* 애그리거트 루트 외에 다른 엔티티가 존재하는데, 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경되었을 경우 JPA 는 루트 엔티티의 버전 값을 증가하지 않는다
  * 연관된 엔티티의 값이 변경된다고 해도 루트 엔티티 자체의 값은 바뀌는 것이 없으므로 루트 엔티티의 버전 값을 갱신하지 않는 것이다
* 이러한 특징은 애그리거트 관점에서 보면 문제가 된다
  * 루트 엔티티가 변경되지 않았더라도, 애그리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 해당 애그리거트는 변경이 된 것이다
  * 따라서 관련된 구성요소가 변경되면 버전이 증가가 되어야 비선점 잠금이 올바르게 동작한다
* JPA 는 이러한 문제를 처리할 수 있도록 `EntityManager#find()` 메서드로 엔티티를 구할 떄 강제로 버전 값을 증가시키는 잠금 모드를 지원한다

```java
pulibc Order findBtyIdOptimisticLockMode(OrderNo id) {
    return entityManager.find(
        order.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT
        // LockModeType.OPTIMISTIC_FORCE_INCREMENT 옵션을 통해, 트랜잭션이 종료될 떄 order 의 변경여부와 상관없이 강제로 버전이 업데이트 된다
    );
}
```

### 오프라인 선점 잠금

* 같은 데이터를 여러 사용자가 동시에 수정하는 것을 막기 위해서는 누군가 수정 화면을 보고 있을 때 수정 화면 자체를 실행하지 못하도록 해야 한다
  * 한 트랜잭션 범위에서만 적용되는 선점 잠금 방식이나, 비선점 잠금 방식으로는 이를 구현할 수 없다
  * 오프라인 선점 잠금 방식을 활용하면 해당 기능을 구현할 수 있다
* 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다
  * 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다
  * 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다
    * 하지만, 잠금을 해제하기 전에 잠금 해제에 대한 기능이나 처리를 하지 않고 강제 종료를 할 경우 다른 사용자는 잠금을 얻을 수 없게 된다.
    * 이를 방지하기 위해, 오프라인 선점 방식은 잠금의 유효 시간을 가져야 한다
    * 하지만 반대로 선점을 하고 있던 사용자가 선점 시간이 만료가 된 이후 변경 요청을 할 경우, 해당 수정사항은 실패하게 된다
    * 이를 방지하기 위한 만료시간 갱신하는 요청등을 하는 방법을 사용할 수 있다
  
#### 오프라인 선점 잠금을 위한 LockManager 인터퍼이스와 관련된 클래스

* 오프라인 선점 잠금은 `잠금 선점 시도`/`잠금 확인`/`잠금 해제`/`락 유효 시간 연장` 네 가지 기능을 제공해야 한다

```java
public interface LockManager {
    LockId tryLock(String type, String id) throws LockException;
    // 잠근 선점 시도
    void checkLock(LockId lockId) throws LockException;
    // 잠금 확인
    void releaseLock(LockId lockID) throws LockException;
    // 잠근 해제
    void extendLockExpiration(LockId lockId, long inc) throws LockExcpetion;
    // 락 유효 시간 연장
}
```
