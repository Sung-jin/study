### 표현 영역과 응용 영역

* 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다
  * 표현 영역은 사용자의 요청을 해석한다
  * 응용 서비스는 실제 사용자가 원하는 기능을 제공하는 영역이다
* 표현 영역은 사용자와의 상호작용을 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다

### 응용 서비스의 역할

* 응용 서비스는 사용자가 요청한 기능을 실행한다
  * 응용 서비스는 사용자의 요청을 처리하기 위해 레파지토리부터 도메인 객체를 구하고, 도메인 객체를 사용한다
* 응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이다
* 응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기하는 단순한 형태를 가진다

```java
public Result doSomeFunc(SomeReq req) {
    // 1. 레파지토리에서 애그리거트를 구한다
    SomeAgg agg = someAggRepository.findById(req.getId());
    
    // 2. 애그리거트의 도메인 기능을 실행한다
    agg.doFunc(req.getValue());
    
    // 3. 결과를 리턴한다
    return createSuccessResult(agg);
}

public Result doSomeCreation(CreateSomeReq req) {
    // 1. 데이터 중복 등 유효검사를 한다
    checkValid(req);
    
    // 2. 애그리거트를 생성한다
    SomeAgg newAgg = createSome(req);
    
    // 3. 레파지토리에 애그리거트를 저장한다
    someAggRepository.save(newAgg);
    
    // 4. 결과를 리턴한다
    return createSuccessResult;
}
```

* 위와 같은 형태보다 복잡할 경우, 대부분 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다
* 도메인 객체 간의 실행 흐름을 제어하는 것과 더불어 응용 서비스의 주된 역할 중 하나는 트랜잭션 처리이다
  * 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 한다
  
```java
public void blockMemeters(String[] blockingIds) {
    if (blockingIds == null || blockingIds.length == 0) return;
    List<Member> members = memberRepository.findByIds(blockingIds);
    for(Member mem: Members) {
        mem.block();
    }
    // 위와 같이 for loop 을 실행하는 도중 중간에 예외가 발생할 경우,
    // 일부 데이터만 적용이 되기 때문에 일관성이 깨지게 되므로
    // 모든 객체는 롤백되어야만 한다
    // 즉, 해당 scope 은 트랜잭션으로 관리되어야 한다
}
```

#### 도메인 로직 넣지 않기

```java
public class Member {
    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw)) throw new badPasswordException();
        setPassword(newPW);
    }
    
    public boolean matchPassword(String pwd) {
        return passwordEncoder.matches(pwd);
    }
    
    private void setPassword(String newPassword) {
        if (isEmpty(newPw)) throw new IllegalArgumentException("no new password");
        this.password = newPassword;
    }
}
// 위와 같이 멤버의 패스워드 변경과 validation 은 도메인의 핵심 로직이며,
// 해당 기능을 응용 서비스에서 구현하면 안된다

public class ChangePasswordService {
    public void changePassword(String memberId, String oldPw, String newPW) {
        Member member = memberRepository.findById(memberId);
        checkMember();
        member.changePassword(oldPw, newPw);
        // 패스워드 유효검사는 도메인의 기능이므로, 위와 같이 응용 서비스에서 해당 기능을 사용만 하면 된다
      
        /*
        if (!passwordEncoder.matches(oldPw, member.getPassword()) throw new BadPasswordException();
        ...
        위와 같이 도메인의 기능을 응용 서비스에서 구현하면 안된다
         */
    }
}
```

* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다
  1. 코드의 응집성이 떨어진다
    * 도메인 데이터와 해당 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않기 때문에, 도메인 로직을 파악하는데 여러 영역을 분석해야 한다
  1. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다
    * 응용 서비스 영역에 별도 보조 클래스를 만들어서 해당 클래스를 사용할 수 있지만, 응집도가 낮아지는건 해결하지 못한다
* 좋은 소프트웨어는 응집도가 높고 확장 결합도는 낮아야 한다

### 응용 서비스의 구현

* 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데, 이는 디자인 패턴의 파사드와 같은 역할을 한다
* 응용 서비스 자체는 복잡한 로직을 수행하지 않다

#### 응용 서비스의 크기

* 응용 서비스는 보통 두 가지 방법 중 한가지 방식으로 구현한다
  1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
    * 각 기능에서 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽다는 점이 장점이다
    * 하지만 한 서비스 클래스의 크기가 커지고, 연관성이 적은 코드가 한 클래스에 함께 위채할 가능성이 높아진다
    * 한 클래스에 코드가 모이기 시작하면 분리하는 것이 좋은 상황임에도 기존 클래스에 억지로 끼워 넣게 된다
  1. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
    * 한 응용 서비스 클래스에서 1~3 개의 기능을 구현한다
    *  클래스의 수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 된다
    * 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복된 코드를 구현할 가능성이 있으나, 해당 부분을 별도 클래스에 구현하여 코드 중복을 방지할 수 있다

#### 응용 서비스의 인터페이스와 클래스

* 인터페이스가 필요한 상황
  1. 구현 클래스가 여러 개인 경우
  1. 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우
* 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 문제가 발생한다

#### 메서드 파라미터와 값 리턴

* 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터를 통해 전달받아야 한다
  * 필요한 값을 각 개별 파라미터로 전달받거나 별도 데이터 클래스를 만들어 전달받을 수 있다
* 표현 영역에서 응용 서비스의 결과가 필요하다면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다
* 응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만, 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다
  * 이는 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다
  
#### 표현 영역에 의존하지 않기

* 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안된다
  * 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워진다
  * 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경되어야 하는 문제가 발생한다
* 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어진다
* 표현 영역의 상태에 해당하는 값을 응용 서비스에서 변경하면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워진다
  * 이는 표현 영역의 응집도가 깨진다
* 즉, 응용 서비스가 표현 영역의 기술을 사용하지 않도록 해야 한다
  * 이를 지키기 위한 가장 쉬운 방법이 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다

#### 트랜잭션 처리

* 변경이나 생성의 실패시 처리가 잘 되어야 문제가 발생하지 않고, 이는 응용 서비스의 중요한 역할이다
* 스프링등과 같은 프레임워크에서 트랜잭션 관리 기능을 제공하고, 해당 기능을 적극 사용하는 것이 좋다
  * 스프링에서 트랜잭션을 사용하면 `RuntimeException` 이 발생하면 트랜잭션을 롤백하고 그렇지 않으면 커밋한다
  
#### 도메인 이벤트 처리

* 응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다
  * 이벤트란 도메인에서 발생한 상태 변경을 의미한다
* 도메인 영역은 상태가 변경되면 이를 외부에 알리기 위한 이벤트를 발생시킬 수 있다
* 도메인에서 이벤트를 발생시키면 그 이벤트를 받아서 처리할 코드가 필요하며, 그 역할은 응용 서비스가 한다
  * 이벤트를 받아서 이벤트에 알맞은 후처리를 할 수 있다
  * ex) 암호 초기화의 경우 암호 초기화 이벤트가 발생하면 변경한 암호를 이메일로 발송하는 이벤트 핸들러를 등록할 수 있다
* 이러한 이벤트를 사용하면 코드가 다소 복잡해지나, 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점이 생긴다
* 이벤트는 시스템을 확장하는데 이벤트가 핵심 역할을 수행한다

### 표현 영역

* 표현 영역의 핵심
  1. 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어한다
  1. 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다
     * 표현 영역은 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환하고 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환하다
  1. 사용자의 세션을 관리한다

### 값 검증

* 값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다
  * 원칙적으로 모든 값 검증은 응용 서비스에서 처리한다
* 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다
  * 스프링 MVC 의 경우 에러 메세지를 보여주기 위한 용도로 Errors 나 BindingResult 를 사용한다
* 값 검증에 try-catch 를 활용한다면, 입력받은 여러 값에 문제가 있을때 처음 문제가 발견된 catch block 에서 리턴을 하니, 그 수 만큼 사용자는 여러번 수정해야 한다
  * 이는 사용자에게 좋지 못한 경험이 된다
  * 이때는 응용 서비스에 값을 전달하기 전에 표현 영역에서 값을 검사하면 된다
* 스프링 등과 같은 프레임 워크에는 값 검증을 위한 Validator 인터페이스를 별도로 제공한다

```java
@Controller
public class Controller {
    @RequestMapping
    public String join(JoinRequest joinRequest, Errors errors) {
        new JoinREquestValidator().validate(joinRequest, errors);
        // 위와 같이 validator 를 구현하여 응용 서비스에 값 검증을 할 수 있다
        if (errors.hasErrors()) return formView;
        
        try {
            joinService.join(joinRequest);
            // 표현 영역에서 필수 값등과 같은 형식을 검사하였기에
            // 응용 서비스는 아이디 중복 여부와 같은 논리적인 오류만 검사만 해도 충분하다
            return sccessView;
        } catch (DuplicateIdException e) {
            errors.rejectValue(ex.getPropertyName(), "duplicate");
            return formView;
        }
    }
}
```

* 응용 서비스를 사용하는 표현 영역 코드가 한 곳이라면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행할 수 있다
  * 표현 영역: 필수 값, 값의 형식, 범위 등을 검증
  * 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증

### 권한 검사

* 스프링 시큐리티 등과 같이 유연하고 확장 가능한 구조를 가지는 권한과 관련된 프레임워크가 존재한다
  * 유연하고 확장 가능한 만큼 복잡하고 사용하기에 따라 유지보수가 힘들어 질 수 있다
  * 무턱대고 도입하기 보다 개발할 시스템에 맞는 권한 검사 기능을 구현하는 것이 시스템 유지보수에 유리할 수도 있다
* 다음 세 곳에서 권한 검사를 수행할 수 있다
  1. 표현 영역
    * 인증된 사용자인지 아닌지 여부를 검사
    * 표현 영역에서의 URL 에 대한 접근 제어
      * 해당 URL 을 처리하는 컨트롤러에 웹 요청을 전달하기 전에 인증 여부를 검사하여 인증된 사용자의 웹 요청만 컨트롤러에 전달한다
      * 인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트 시킨다
    * 이러한 접근 제어를 하기 좋은 위치는 서블릿 필터이다
      * 서블릿 필터는 사용자의 인증 정보를 생성하고 인증 여부를 검사하는 것이다
  1. 응용 서비스
    * URL 만으로 접근 제어가 불가능 할 때는 서비스의 메서드 단위로 권한 검사를 수행해야 한다
      * 이는 응용 서비스의 코드에서 직접 권한 검사를 해야만 하는 것이 아닌, 스프링 시큐리티의 AOP 를 활용하여 어노테이션으로 서비스 메서드에 대한 권한 검사를 하는 등으로 처리할 수 있다
  1. 도메인
    * 게시글 삭제의 기능을 작성한 본인 또는 관리자만 가능하다고 할 때에는 URL, 메서드 단위가 아닌 도메인 단위의 권한 검사가 수행되어야 한다
      * 게시글 애그리거트를 먼저 로딩하고 요청한 사용자가 권한을 가지고 있는지 여부를 확인해야 하기 때문이다

### 조회 전용 기능과 응용 서비스

* 서비스에서 조회 전용 기능을 사요하게 되면, 서비스 코드는 단순히 조회 전용 기능을 호출하고 끝나는 경우가 많다
* 서비스에서 수행하는 추가적인 로직이 없고, 조회 전용 기능이여서 트랜잭션도 필요하지 않으므로 표현 영역에서 바로 조회 전용 기능을 사용해도 괜찮다
  * 응용 서비스가 존재해야만 한다고 생각한다면, 표현 영역에서 응용 서비스 없이 조회 전용 기능이나 도메인 레파지토리에 접근하는 것이 이상할 수 있다
