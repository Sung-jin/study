### 표현 영역과 응용 영역

* 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다
  * 표현 영역은 사용자의 요청을 해석한다
  * 응용 서비스는 실제 사용자가 원하는 기능을 제공하는 영역이다
* 표현 영역은 사용자와의 상호작용을 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다

### 응용 서비스의 역할

* 응용 서비스는 사용자가 요청한 기능을 실행한다
  * 응용 서비스는 사용자의 요청을 처리하기 위해 레파지토리부터 도메인 객체를 구하고, 도메인 객체를 사용한다
* 응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것이다
* 응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기하는 단순한 형태를 가진다

```java
public Result doSomeFunc(SomeReq req) {
    // 1. 레파지토리에서 애그리거트를 구한다
    SomeAgg agg = someAggRepository.findById(req.getId());
    
    // 2. 애그리거트의 도메인 기능을 실행한다
    agg.doFunc(req.getValue());
    
    // 3. 결과를 리턴한다
    return createSuccessResult(agg);
}

public Result doSomeCreation(CreateSomeReq req) {
    // 1. 데이터 중복 등 유효검사를 한다
    checkValid(req);
    
    // 2. 애그리거트를 생성한다
    SomeAgg newAgg = createSome(req);
    
    // 3. 레파지토리에 애그리거트를 저장한다
    someAggRepository.save(newAgg);
    
    // 4. 결과를 리턴한다
    return createSuccessResult;
}
```

* 위와 같은 형태보다 복잡할 경우, 대부분 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다
* 도메인 객체 간의 실행 흐름을 제어하는 것과 더불어 응용 서비스의 주된 역할 중 하나는 트랜잭션 처리이다
  * 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리해야 한다
  
```java
public void blockMemeters(String[] blockingIds) {
    if (blockingIds == null || blockingIds.length == 0) return;
    List<Member> members = memberRepository.findByIds(blockingIds);
    for(Member mem: Members) {
        mem.block();
    }
    // 위와 같이 for loop 을 실행하는 도중 중간에 예외가 발생할 경우,
    // 일부 데이터만 적용이 되기 때문에 일관성이 깨지게 되므로
    // 모든 객체는 롤백되어야만 한다
    // 즉, 해당 scope 은 트랜잭션으로 관리되어야 한다
}
```

#### 도메인 로직 넣지 않기

```java
public class Member {
    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw)) throw new badPasswordException();
        setPassword(newPW);
    }
    
    public boolean matchPassword(String pwd) {
        return passwordEncoder.matches(pwd);
    }
    
    private void setPassword(String newPassword) {
        if (isEmpty(newPw)) throw new IllegalArgumentException("no new password");
        this.password = newPassword;
    }
}
// 위와 같이 멤버의 패스워드 변경과 validation 은 도메인의 핵심 로직이며,
// 해당 기능을 응용 서비스에서 구현하면 안된다

public class ChangePasswordService {
    public void changePassword(String memberId, String oldPw, String newPW) {
        Member member = memberRepository.findById(memberId);
        checkMember();
        member.changePassword(oldPw, newPw);
        // 패스워드 유효검사는 도메인의 기능이므로, 위와 같이 응용 서비스에서 해당 기능을 사용만 하면 된다
      
        /*
        if (!passwordEncoder.matches(oldPw, member.getPassword()) throw new BadPasswordException();
        ...
        위와 같이 도메인의 기능을 응용 서비스에서 구현하면 안된다
         */
    }
}
```

* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다
  1. 코드의 응집성이 떨어진다
    * 도메인 데이터와 해당 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않기 때문에, 도메인 로직을 파악하는데 여러 영역을 분석해야 한다
  1. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다
    * 응용 서비스 영역에 별도 보조 클래스를 만들어서 해당 클래스를 사용할 수 있지만, 응집도가 낮아지는건 해결하지 못한다
* 좋은 소프트웨어는 응집도가 높고 확장 결합도는 낮아야 한다

### 응용 서비스의 구현

* 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데, 이는 디자인 패턴의 파사드와 같은 역할을 한다
* 응용 서비스 자체는 복잡한 로직을 수행하지 않다

#### 응용 서비스의 크기

* 응용 서비스는 보통 두 가지 방법 중 한가지 방식으로 구현한다
  1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
    * 각 기능에서 동일한 로직을 위한 코드 중복을 제거하는 것이 쉽다는 점이 장점이다
    * 하지만 한 서비스 클래스의 크기가 커지고, 연관성이 적은 코드가 한 클래스에 함께 위채할 가능성이 높아진다
    * 한 클래스에 코드가 모이기 시작하면 분리하는 것이 좋은 상황임에도 기존 클래스에 억지로 끼워 넣게 된다
  1. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
    * 한 응용 서비스 클래스에서 1~3 개의 기능을 구현한다
    *  클래스의 수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는데 도움이 된다
    * 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복된 코드를 구현할 가능성이 있으나, 해당 부분을 별도 클래스에 구현하여 코드 중복을 방지할 수 있다

#### 응용 서비스의 인터페이스와 클래스

* 인터페이스가 필요한 상황
  1. 구현 클래스가 여러 개인 경우
  1. 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우
* 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 문제가 발생한다

#### 메서드 파라미터와 값 리턴

* 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터를 통해 전달받아야 한다
  * 필요한 값을 각 개별 파라미터로 전달받거나 별도 데이터 클래스를 만들어 전달받을 수 있다
* 표현 영역에서 응용 서비스의 결과가 필요하다면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다
* 응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만, 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다
  * 이는 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다
  
#### 표현 영역에 의존하지 않기

* 응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안된다
  * 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워진다
  * 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경되어야 하는 문제가 발생한다
* 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어진다
* 표현 영역의 상태에 해당하는 값을 응용 서비스에서 변경하면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워진다
  * 이는 표현 영역의 응집도가 깨진다
* 즉, 응용 서비스가 표현 영역의 기술을 사용하지 않도록 해야 한다
  * 이를 지키기 위한 가장 쉬운 방법이 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다

#### 트랜잭션 처리

* 변경이나 생성의 실패시 처리가 잘 되어야 문제가 발생하지 않고, 이는 응용 서비스의 중요한 역할이다
* 스프링등과 같은 프레임워크에서 트랜잭션 관리 기능을 제공하고, 해당 기능을 적극 사용하는 것이 좋다
  * 스프링에서 트랜잭션을 사용하면 `RuntimeException` 이 발생하면 트랜잭션을 롤백하고 그렇지 않으면 커밋한다
  
#### 도메인 이벤트 처리

* 응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다
  * 이벤트란 도메인에서 발생한 상태 변경을 의미한다
* 도메인 영역은 상태가 변경되면 이를 외부에 알리기 위한 이벤트를 발생시킬 수 있다
* 도메인에서 이벤트를 발생시키면 그 이벤트를 받아서 처리할 코드가 필요하며, 그 역할은 응용 서비스가 한다
  * 이벤트를 받아서 이벤트에 알맞은 후처리를 할 수 있다
  * ex) 암호 초기화의 경우 암호 초기화 이벤트가 발생하면 변경한 암호를 이메일로 발송하는 이벤트 핸들러를 등록할 수 있다
* 이러한 이벤트를 사용하면 코드가 다소 복잡해지나, 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점이 생긴다
* 이벤트는 시스템을 확장하는데 이벤트가 핵심 역할을 수행한다
