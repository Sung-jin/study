### 여러 애그리거트가 필요한 기능

* 한 애그리거트로 기능을 구현할 수 없을 때가 많다
  * 예를들어 결제 금액 계싼 로직 등이 있다
    * 상품 애그리거트: 구매하는 상품의 가격이 필요하며, 상품에 따라 배송비가 추가되기도 한다
    * 주문 애그리거트: 상품별로 구매 개수가 필요하다
    * 할인 쿠폰 애그리거트: 쿠폰별로 지정한 할인 금액이나 비율에 따라 주문 총 금액을 할인한다
    * 회원 애그리거트: 회원 등급에 따라 추가 할인이 가능하다
* 위와 같은 상황에서 금액을 계싼해야 하는 주체는 어떤 애그리거트인가?
  * 총 주문 금액을 계산하는 것은 주문 애그리거트가 할 수 있지만, 실제 결제 금액은 총 주문 금액에서 할인 금액을 계산하는 등의 이슈가 발생한다
* 여러가지 관계가 엮여있는 등의 문제를 한 애그리거트에 넣기에 애매한 도메인 기능을 특정 애그리거트에 억지로 구현하면 문제가 발생한다
  * 이 경우 애그리거트는 자신의 책임 범위를 넘어서는 기능을 구현하기 떄문에 코드가 길어지고, 외부에 대한 의존이 높아지게 된다
  * 즉, 코드의 복잡도가 높아지고 수정을 어렵게 만드는 요인이 된다
  * 또한 애그리거트의 범위를 넘어서는 도메인 개념이 애그리거트에 숨어들어서 명시적으로 드러나지 않게 된다
* 이러한 문제를 해소하는 가장 쉬운 방법은 도메인 서비스를 별도로 구현하는 것이다

### 도메인 서비스

* 특정 애그리거트에 넣기 애매한 도메인 개념을 억지로 애그리거트에 넣기 보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다
  * 응용 영역의 서비스가 응용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다룬다
* 도메인 서비스가 도메인 영역의 애그리거트나 벨류와 같은 다른 구성요소와 비교할 때 다른 점이 있다면 상태 없이 로직만 구현한다는 점이다
  * 도메인 서비스를 구현하는 데 필요한 상태는 애그리거트나 다른 방법으로 전달받는다
* 도메인 서비스는 도메인의 의미가 드러나는 용어를 타입과 메서드 이름으로 가진다

```java
public class DiscountCalculationService {
    ...
    // 할인과 관련된 필드
    
    public Money calculateDiscountAmounts(...) {
        ...
    }
    
    // 할인과 관련된 이름의 메소드
}

public class Order {
    public void calculateAmounts(DiscountCalculationService disCalSvc, ...) {
        Money discountAMounts = disCalSvc.calculateDiscountAmounts(...);
        ...
    }
    // 위와 같이 할인 계싼 서비스를 애그리거트가 사용하는 주체가 될 수 있다
}

public class OrderService {
    private DiscountCalculationService discountCalculationService;
    
    @Transactional
    public OrderNo placeOrder(...) {
        ...
      
        order.calculateAmounts(discountCalculationService, ...);
        
        return order.orderNo;
    }
    // 위와 같이 애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스의 책임이다
} 
```

* 위와 같이 `할인` 이라는 도메인 서비스를 생성한다면, 할인이라는 의미가 드러나는 이름을 사용한다
* 애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하여 사용할 수도 있다

#### 도메인 서비스 객체를 애그리거트에 주입하지 않기

* 애그리거트의 메서드를 실행할 때 도메인 서비스 객체를 파라미터로 전달한다는 것은 애그리거트가 도메인 서비스에 의존한다는 것을 뜻한다
* 도메인 객체는 필드로 구성된 데이터와 메서드를 이용한 기능을 이요해서 개념적으로 하나인 모델을 표현한다
  * 모델의 데이터를 담는 필드는 모델에서 중요한 구성요소이다
  * 하지만, 도메인 객체에 주입된 도메인 서비스는 데이터 자체와 관련이 없다
* 즉, 관련이 없는 서비스를 주입해야 할 이유는 없다

### 도메인 서비스의 패키지 위치

* 도메인 서비스는 도메인 로직을 실행하므로 도메인 서비스의 위치는 다른 도메인 구성 요소와 동일한 패키지에 위치한다
  * 즉, 주문 금액 계싼을 위한 도메인 서비스는 주문 애그리거트와 동일 패키지에 위치한다
* 도메인 하위에 모델, 서비스, 레파지토리가 많거나 구분을 원한다면, domain.model/service/repository 와 같이 하위 폴더로 구분할 수 있다

### 도메인 서비스의 인터페이스와 클래스

* 도메인 서비스의 로직이 고정되어 있지 않은 경우 도메인 서비스 자체를 이너페이스로 구현하고, 이를 구현한 클래스를 둘 수 있다
  * 특히 외부 시스템이나 별도 엔진을 이용해서 구현해야 할 경우, 인터페이스와 클래스를 분리하게 된다
  * 도메인 영역에는 도메인 서비스 인터페이스가 위치하고, 실제 구현은 인프라스트럭처 영역에 위치할 수 있다