### QueryDSL

* JPQL 빌더 역할을 하며, Criteria 를 대체할 수 있다.
* 오픈소스 프로젝트이다.
* 데이터 조회하는 데 기능이 특화되어 있다.

#### 설정

* QueryDSL 디펜던시를 maven, gradle 등에 추가한다.
* querydsl-jpa, querydsl-apt
    * querydsl-apt 는 쿼리 타입(Q) 을 생성할 때 필요한 라이브러리 이다.
    * Criteria 의 메타 모델 API 와 비슷하다.
    * 즉, Criteria 의 메타 모델 API 에 사용될 엔티티를 생성하는 플러그인을 추가해야한다.
    * 설정 후 mvn compile 등을 실행하면 QEntity 형태의 클래스가 생성된다.

#### 시작

```java
...

JPAQuery query = new JPAQuery(em);
QMember qMember = new QMember("m");
// JPQL 의 별칭이 m 으로 설정된다.

List<Member> members = query.from(qMember)
                            .where(qMember.name.eq("value"))
                            .orderBy(qMember.name.desc())
                            .list(qMember);

/*
JPQL

SELECT m FROM Member m
WHERE m.name = ?1
ORDER BY m.name desc
 */
```

```java
// QEntity
public class QEntity extends EntityPathBase<Entity> {
    public static final QEntity entity = new QEntity("someAlias");
    // 생성된 Q 클래스에 기본 인스턴스가 정의되어 있다.
    // 해당 값으로 엔티티를 조회에 사용해도 되지만, 서브쿼리 등을 사용할 때는 별도의 별칭을 지정해줘야 한다.
}

...

QEntity qEntity = new QEntity("foo");   // foo 라는 별칭 지정
QEntity qEntity = QEntity.entity;       // 기본 인스턴스 사용

// 기본 인스턴스의 경우 static final 이므로 import static 을 통해 사용할 수 있다.
```

#### 검색 조건 쿼리

```java
JPAQuery query = new JPAQuery(em);
QEntity entity = QEntity.entity;
List<Entity> list = query.from(entity)
                        .where(entity.field.eq("value").and(entity.numField.gt(10000)))
//                        .where(entity.field.eq("value"), (entity.numField.gt(10000)))
//                        where 에 , 를 통해 구분할 수 있으며 이때는 and 로 묶인다.
                        .list(entity);

/*
where 에 사용되는 일부 메소드
.between(value1, value2)
.contains(value)            like %value%
.startsWith(value)          like value%

결과 조회 메소드
uniqueResult()  조회 결과가 한 건일 때 사용되며 조회 결과가 없으면 null, 한개 초과시 NonUniqueResultException 예외가 발생한다.
singleResult()  uniqueResult() 와 같지만, 결과가 한개 초과시 맨 처음 데이터를 리턴한다.
list()          결과가 없다면 빈 컬렉션을 반환한다.
 */

/*
JPQL

SELECT entity
FROM Entity entity
WHERE entity.field = ?1 AND entity.numField > ?2
 */
```

#### 페이징과 정렬

```java
JPAQuery query = new JPAQuery(em);
QEntity entity = QEntity.entity;
query.from(entity)
    .where(entity.field.eq("value"))
    .orderBy(item.field2.desc())
    .offset(10).limit(20)
    .listResults(entity);

QueryModifiers queryModifiers = new QueryModifiers(20L, 10L);   //limit, offset
query.from(entity)
    .restrict(queryModifiers)
    .listResults(entity);
// QueryModifiers 를 통해서도 페이징 처리가 가능하다.

// listResults 를 통해 결과를 반환하면 페이징 처리된 결과를 받을 수 있다.

long total = result.getTotal();
long limit = result.getLimit();
long offset = result.getOffset();
List<Entity> results = result.getResults();
```

#### 그룹

```java
query.from(entity)
    .groupBy(entity.field)
    .having(entity.numField.gt(1000))
    .list(entity);
```

#### 조인

```java
QOrder order = QOrder.order;
QMember member = QMember.member;
QOrderItem orderItem = QOrderItem.orderItem;

query.from(order)
    .join(order.member, member)
    .leftJoin(order.orderItems, orderItem)
    .list(order);
// 기본 조인

query.from(order)
    .leftJoin(order.orderItems, orderItem)
    .on(orderItem.count.gt(2))
    .list(order);
// on 절을 이용한 조인

query.from(order)
    .innerJoin(order.member, member).fetch()
    .leftJoin(order.orderItems, orderItem).fetch()
    .list(order);
// fetch 조인

query.from(order, member)
    .where(order.member.eq(member))
    .list(order);
// 세타 조인
```

#### 서브 쿼리

```java
QEntity entity = QEntity.item;
QEntity subEntity = new QEntity("subEntity")

query.from(entity)
    .where(entity.field.eq(
        new JPASubQuery().from(subEntity).where(subEntity.id.eq(100))
    ))
/*
    .where(entity.field.in(
        new JPASubQuery().from(subEntity)
        .where(subEntity.field2.gt(100))
        .list(subEntity)
    )    
 */
    .list(entity);

/*
JPQL

SELECT e FROM Entity e
WHERE e.field = (
    SELECT subEntity.id FROM Entity subEntity WHERE subEntity.id = 100
)

SELECT e FROM Entity e
WHERE e.field = (
    SELECT subEntity.id FROM Entity subEntity WHERE subEntity.id > 100
)
 */
```
