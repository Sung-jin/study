## 정리

### 테스트

* 테스트는 자동화되어야 하고, 빠르게 실행할 수 있어야 한다
* 테스트 결과는 일관성이 있어야 되며, 코드의 변경 없이 환경이나 테스트 실행 순서에 따라 결과가 달라지면 안된다
* 테스트는 포괄적으로 작성해야 한다
* 코드 작성과 테스트 수행의 간격이 짧을수록 좋다
* 테스트하기 쉬운 코드가 좋은 코드이다
* 테스트 주도 개발(Test-Driven-Development) 방법을 통해 테스트를 먼저 작성하고 테스트를 성공시키는 코드를 작성하는 형태로 개발하는 것은 많은 도움이 된다
* 기능 코드의 리펙토링처럼 테스트 코드도 리펙토링이 필요하다
* 동일한 설정파일을 사용하는 테스트는 하나의 어플리케이션 컨텍스트를 공유한다
* 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면, 버그 해결에도 도움이 되고 추후 유지보수에도 도움이 된다

## 템플릿

* 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 자원 회수와 예외에 대한 처리가 필요하다
* 일정한 작업 흐름이 반복되면서 일부 기능만 바뀌는 코드가 존재한다면, 전략 패턴을 적용한다
  * 바뀌지 않는 부분은 컨텍스트로, 변경되는 부분을 전략으로 만들어 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다
  * 같은 어플리케이션 안에서 여러 종류의 전략을 다이나믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다
* 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리하여 공유하도록 한다
* 컨텍스트는 별도의 빈으로 등록하여 DI 받거나 클라이언트 클래스에서 직접 생성하여 사용한다
  * 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용하여 직접 DI 할 수 있다
* 단일 전략 메소드를 가지는 전략 패턴이면서 익명 내부 클래스를 사용하여 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI 를 수행하는 방식을 '템플릿/콜백 패턴' 이라고 한다
* '템플릿/콜백' 을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다

## 예외

* 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다
* 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다
* 좀더 의미 있는 예외로 변경하거나, 불필요한 catch/throws 를 피하기 위해 런타임 예외로 포장하는 예외 전환이 있다
* 복구할 수 없는 예외는 런타임 예외로 전환하는 것이 바람직하다
* 어플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다
* SQLException 에러 코드는 DB 에 종속되기 때문에 DB 에 독립적인 예외로 전환될 필요가 있다
  * 스프링은 DataAccessException 을 통해 DB 에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다
* DAO 를 data access 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다

## 서비스 추상화

* 비즈니스 로직을 담은 코드는 data access 코드와 깔끔하게 분리되는 것이 좋다
  * 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라 깔끔하게 메소드로 정리되어야 한다
* DAO 의 기술 변화에 서비스 계층의 코드가 여ㅛㅇ향을 받지 않도록 인터페이스와 DI 를 잘 활용하여 결합도를 낮춰야 한다
* DAO 를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다
  * 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO 로 전달하는 방법은 매우 비효율적이기 때문에, 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 좋다
* 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO 가 사용하는 특정 기술에 대한 강한 결합을 만들어낸다
  * 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다
* 서비스 추상화는 로우레벨의 트랜잭션 기술과 API 의 변화에 상관없이 일관된 API 를 가진 추상화 계층을 도입한다
  * 서비스 추상화를 통해 테스트하기 어려운 기술에 적용하여 테스트를 편리하게 작성할 수 있게 할 수 있다
* 테스트 대역은 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다
  * 테스트 대역은 테스트 대상 오브젝트가 원할하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다
  * 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 mock object 라고 한다

## AOP

* 트랜잭션 경계설정 코드를 분리하여 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI 의 확장 기능을 이용하여 클라이언트의 변경 없이 깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다
* 외부 리소스에 영향받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다
* Mock 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 쉽게 고립된 테스트로 만들 수 있다
* DI 를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다
* 프록시 클래스 작성은 JDK 의 다이나믹 프록시를 사용하면 간단하게 만들수 있다
  * 다이나믹 프록시는 스태틱 팩토리 메소드를 사용하기 때무느에 빈으로 등록하기 번거로우며, 팩토리 빈으로 만들어야 한다
  * 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다
* 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 이용할 수 있다
  * 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다
* 포인트컷은 AspectJ 포인트컷 표현식을 사용하여 작성하면 편하다
* AOP 는 OOP 만으로 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다
* 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있느 전용 태그를 제공한다
* AOP 를 이용하여 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 `@Transactional` 을 사용하는 방법이 있다
* `@Transactional` 을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB 를 사용하는 코드의 테스트를 만들 수 있다

## 스프링 핵심 기술의 응용

* SQL 과 같은 변경될 수 잇는 텍스트 정보는 외부 리소스에 담아두고 가져오게 마들면 편리하다
* 성격이 다른 코드가 섞여 있는 클래스라면, 인터페이스를 정의하여 코드를 각 인터페이스별로 분리하는게 좋다
  * 다른 인터페이스에 속한 기능은 인터페이스를 통해 접근하게 만들고, 간단히 자기참조 빈으로 의존관계를 만들어 검증한다
  * 검증 후 클래스를 아에 분리하는 것도 좋다
* 자주 사용되는 의존 오브젝트는 디폴트로 미리 정의해두면 편하다
* XML 과 오브젝트 매핑은 스프링의 OXM 추상화 기능을 활용한다
* 특정 의존 오브젝트를 고정하여 기능을 특화하려면 멤버 클래스로 만드는 것이 편리하다
  * 기존에 만들어진 기능과 중복되는 부분은 위임을 통해 중복을 제거하는 것이 좋다
* 외부 파일이나 리소스를 사용하는 코드에서 스프링의 리소스 추상화와 리소스 로더를 사용한다
* DI 를 의식하며 코드를 작성하면 객체지향 설계에 도움이 된다
  * DI 에는 인터페이스를 사용하고, 인터페이스를 사용하면 인터페이스 분리 원칙을 잘 지키는데 도움이 된다
* 클라이언트에 ㄷ따라 인터페이스를 분리할 때, 새로운 인터페이스를 만드는 방법과 인터페이스를 상속하는 방법 두가지를 사용할 수 있다
* 애플리케이션에 내장하는 DB 를 사용할 때는 스플링의 내장형 DB 추상화 기능과 전용 태그를 사용하면 편리하다
