### 웹 서버

* HTTP 기반으로 동작
* 정적 리소스와 기타 부가기능을 제공한다
    * 정적 HTML, CSS, JS, 이미지, 영상...
    * NGINX, APACHE
    
### 웹 어플리케이션 (Web Application Server)

* HTTP 기반으로 동작하며 웹 서버 기능도 포함되어 있다
* 프로그램 코드를 실행해서 어플리케이션 로직을 수행한다
    * 동적 HTML, HTTP API...
    * Jetty, Undertow
    
### 웹 시스템 구성

* WAS + DB
    * WAS 에서 동적/정적 리소스를 제공하고, 데이터베이스와 통신을 하는 등 충분히 서비스를 제공할 수 있는 시스템을 구성할 수 있다
    * 하지만, WAS 가 너무 많은 역할을 담당을 하며 장애, 과부하 등 여러가지 고려해야 할 부분이 많다
* WEB + WAS + DB
    * 정적 리소스는 웹 서버가 처리
    * 로직과 같은 동적인 처리가 필요하면 WAS 에서 처리
    * WEB/WAS 가 각각 필요한 수 만큼 증설이 쉽다
    * WEB 서버는 장애가 발생할 확률이 낮으며, WEB 서버에 오류화면 HTML 을 설정하면 WAS 가 장애시 오류 화면을 보여줄 수 있다
    
### 서블릿

```java
@WebServlet(name = "helloServlet", urlPatterns = "/path")
// urlPatterns 의 URL 이 호출되면 서블릿 코드가 실행된다
public class HelloServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpSErvletResponse response) {
        // 어플리케이션 로직
    }
    // HttpServletRequest: HTTP 요청 정보를 편리하게 사용할 수 있다
    // HttpServletResponse: HTTP 응답 정보를 편리하게 사용할 수 있다

}
```

#### 서블릿의 HTTP 요청과 응답의 흐름

1. WAS 는 Request, Response 객체를 새로 만들어서 서블릿 객체를 호출
1. 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
1. 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 가능
1. WAS 는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

#### 서블릿 컨테이너

* 톰캣과 같이 서블릿을 지원하는 WAS 를 서블릿 컨테이너라고 한다
* 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 소출, 종료하는 생명주기를 관리한다
* 서블릿 객체는 싱글톤으로 관리된다
    * 클라이언트의 요청 시 마다 객체를 생성하는 것은 비효율적이다
    * 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용이 가능하다
    * 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근된다
    * 서블릿 컨테이너 종료시 함께 종료된다
    * 싱글톤으로 동작하기 때문에 공유 변수 사용에 주의를 해야 한다
* JSP 도 서블릿으로 변환 되어서 사용된다
* 동시 요청을 위한 멀티 스레드 처리를 지원한다

### 스레드

* 어플리케이션 코드를 하나하나 순차적으로 실행하는 것은 스레드이다
    * 자바 메인 메소드를 처음 실행하면 main 이라는 스레드가 실행된다
* 스레드는 한번에 하나의 코드 라인만 수행한다 
    * 동시 처리가 필요 할 경우 스레드를 추가로 생성해야 한다

#### 요청 마다 스레드 생성의 장단점

* 장점
    * 동시 요청을 처리할 수 있다
    * 리소스가 허용할 때 까지 처리가 가능하다
    * 하나의 스레드가 지연되어도 다른 스레드는 정상 동작한다
* 단점
    * 스레드 생성 비용은 매우 비싸다
    * 스레드는 컨텍스트 스위칭 비용이 발생한다
    * 스레드 생성에 제한이 없다
        * 많은 요청에 의해 스레드가 많이 생성되면, CPU/메모리의 임계점을 넘어서 서버가 죽을 수 있다

#### 스레드 풀

* 스레드를 미리 생성해둔 묶음
* 스레드가 필요하면 놀고있는 스레드를 가져다가 작업을 수행할 수 있다
    * 생성, 제거하는 비용을 줄일 수 있다
    * 해당 시간만큼 응답 시간을 줄일 수 있다
    * 갑자기 많은 요청이 오더라도 기존의 작업들은 이미 스레드에 의해 동작하고 있으므로 정상 수행될 수 있다 (갑작스러운 요청에 의해 서버 상태가 나빠지는 등의 요인은 제외)
* 스레드 풀보다 많은 요청이 오면 요청을 거부하거나 유효 스레드가 생길 때 까지 대기할 수 있다
* 스레드 풀의 적정 숫자
    * 어플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 등 여러 상황에 따라 모두 다르다
    * 성능 테스트 등을 통해 사이즈를 예상하여 정해야 한다
        * 툴로는 아파치 ab, 제이미터, nGrinder 등이 있다

#### WAS 의 멀티 스레드 지원

* 멀티 스레드에 대한 부분은 WAS 가 처리
    * 즉, 개발자가 멀티 스레드 관련 코드를 신경쓰지 않아도 된다
* 멀티 스레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈...)는 주의해서 사용해야 한다

##### 스레드 풀 팁

* WAS 의 주요 튜닝 포인트는 max thread 수이다
    * 너무 낮을경우 동시 요청이 많아지면 서버 리소스는 여유로우나 클라이언트 응답 지연률이 높아진다
    * 너무 높은경우 동시 요청이 많아지면 CPU, 메모리 리소스 임계점 초과로 인한 서버가 다운될 수 있다

### HTTP API

* 다양한 시스템에서 호출
* 데이터만 주고 받으며, UI 화면이 필요하다면 클라이언트가 별도로 처리한다
* 앱, 웹 클라이언트, 서버간 통신 등에 사용된다
* 주로 JSON 데이터로 통신된다

### Server Side Rendering

* 서버사이드 렌더링
* HTML 최종 결과를 서버에서 생성하여 웹 브라우저에 전달한다
* 주로 정적인 화면에 사용된다
    * 자바스크립트를 사용해서 화면 일부를 동적으로 변경을 할 수 있다
* JSP, 타임리프 등이 존재한다

### Client Side Rendering

* 클라이언트 사이드 렌더링

* HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용한다
* 주로 동적인 화면에 사용되며, 웹 환경을 마치 앱 처럼 필요한 부분부문만 변경할 수 있다
* React, Vue.js 등이 존재한다
