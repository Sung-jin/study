## 비즈니스 요구사항과 설계

### 회원
* 회원을 가입하고 조회할 수 있다
* 회원은 일반과 VIP 등급이 있다
* 회원 데이터는 자체 DB 를 구축할 수 있고, 외부 시스템과 연동할 수 있다 (미확정)

![](./img/1_user_domain_design_1.png)

* 위와 같이 나중에 어떠한 저장소를 선택하여도 쉽게 변경 가능하게 설계를 하여 추후 변경을 쉽게 대응할 수 있다
* 도메인 협력 관계의 경우 기획자가 볼 수 있다

![](./img/1_user_domain_design_2.png)

* 도메인 협력 관계를 통해 클래스 다이어그램을 작성할 수 있다

![](./img/1_user_domain_design_3.png)

* 서버가 실제 실행되어 클라이언트가 실제로 사용하는 것을 보여준다

#### 회원 설계의 문제점

* 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제가 있음

### 주문과 할인 정책

* 회원은 상품을 주문할 수 있다
* 회원 등급에 따라 할인 정책을 적용할 수 있다
* 할인 정책은 VIP 인 경우 1,000 원을 고정으로 할인한다
  * 상세한 할인 정책은 정해지지 않았으며, 추후 변경 가능성이 존재한다

![](./img/1_user_domain_design_4.png)

1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다
1. 회원 조회: 할인을 위해서는 회원 등급이 필요하다.
    * 주문 서비스는 회원 저장소에서 회원을 조회한다
1. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다
1. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과륿 반환한다

![](./img/1_user_domain_design_5.png)

* 역할과 구현을 분리해서 자유롭게 구현 객체를 조립할 수 있게 설계할 수 있다
  * 결과적으로 회원 저장소와 할인 정책은 유연하게 변경될 수 있다

![](./img/1_user_domain_design_6.png)

![](./img/1_user_domain_design_7.png)

* 위와 같이 회원을 메모리나 DB 어떤것으로 조회를 하고, 어떠한 할인 정책을 적용하더라도 주문 서비스를 변경하지 않아도 된다
    * 역할들의 협력 관계를 그대로 사용할 수 있다

### 좋은 객체 지향 설계의 5가지 원칙의 적용

#### SRP 단일 책임 원칙

* 한 클래스는 하나의 책임만 가져야 한다
    * 클라이언트 객체는 직접 구현 객체를 생성하고, 연결하고, 실행하는 다양한 책임을 가지고 있다
    * SRP 단일 책임 원칙을 따르면서 관심사를 분리
    * 구현 객체를 생성하고 연결하는 책임은 AppConfig 가 담당
    * 클라이언트 객체는 실행하는 책임만 담당
    
#### DIP 의존관계 역전 원칙

* 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다" 의존성 주입은 이 원칙을 따르는 방법 중 하나이다
* 새로운 할인 정책을 개발하고, 적용하려고 할 때 클라이언트 코드도 함께 변경을 해야하는 경우가 발생했다
    * 기존 클라이언트 코드인 `OrderServiceImpl` 은 DIP 를 지키며, `DiscountPolicy` 추상화 인터페이스에 의존하는 것 같았지만, `FixDiscountPolicy` 라는 구체화 구현 클래스에도 의존했었다
    * 이러한 구조에서 `DiscountPolicy` 추상화 인터페이스에만 의존하도록 코드를 변경하였으나, 클라이언트 코드는 인터페이스만으로는 실행이 불가능했다
    * `AppConfig` 를 통해 추상화 인터페이스에 실제 구현된 객체를 주입함으로 클라이언트 코드에 의존관계를 주입하여 DIP 원칙을 따르면서 문제를 해결하였다
    
#### OCP

* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다
* 다형성을 사용하여 클라이언트가 DIP 를 지켰다
* 애플리케이션을 사용 영역과 구성 영역으로 나누었다
* `AppConfig` 가 의존관계를 `FixDiscountPolicy` -> `RateDiscountPolicy` 로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 된다
* 즉, 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있게 되었다

#### 제어의 역전 (IoC - Inversion of Control)

* 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행하였다
    * 구현 객체가 프로그램의 제어 흐름을 스스로 조종하였다
    * 이는 개발자 입장에서 자연스러운 흐름이다
* 하지만 `AppConfig` 가 등장한 후 구현 객체는 자신의 로직을 실행하는 역할만 담당하게 되었다
    * 프로그램의 제어 흘므은 이제 `AppConfig` 가 가져간다
* 프로그램에 대한 제어 흐름에 대한 권한은 모두 `AppConfig` 가 가지고 있다
* 프레임 워크 vs 라이브러리
    * 내가 작성한 코드를 제어하고 대신 실행하면 그것은 프레임워크이다 (JUnit...)
    * 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리이다

#### 의존 관계 주입 (DI - Dependency Injection)

* 의존관계는 **정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계** 들을 분리해서 생각해야 한다
* 정적인 클래스 의존관계
    * `import` 코드를 통해 의존관계를 쉽게 판단할 수 있다
    * 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다
* 동적인 객체 인스턴스 의존 관계
    * 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계이다
    * 애플리케이션 실행 시점(런타임) 에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 **의존관계 주입** 이라고 한다
    * 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다
    * 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다
    * 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다

### 스프링 컨테이너

* `ApplicationContext` 를 스프링 컨테이너라고 한다
* 기존에는 개발자가 `AppConfig` 를 사용해서 직접 객체를 생성하고 DI 를 하였지만, 스프링 컨테이너를 통해 DI 를 할 수 있게 된다
* 스프링 컨테이너는 `@Configuration` 이 붙은 설정 정보를 사용한다
    * `@Bean` 이라는 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다
    * 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다
* 스프링 빈은 `@Bean` 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다
    * 스프링 컨테이너를 통해 필요한 스프링 빈(객체)를 찾아서 사용할 수 있다
    * 이러한 스프링 빈은 `applicationContext.getBean()` 메서드로 찾을 수 있다
* 기존에는 개발자가 직접 자바코드로 모든 것을 했지만, 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다

### 스프링 컨테이너 생성

```java
ApplicationContext applicationContext = new ApplicationConfigApplicationContext(AppConfig.class);
// 스프링 컨테이너 생성
// 해당 코드에서는 AppConfig 를 기반으로 스프링 컨테이너를 생성함
// ApplicationConfigApplicationContext 은 ApplicationContext 인터페이스의 구현체이다
```

* `ApplicationContext` 를 스프링 컨테이너라고 한다
    * `ApplicationContext` 는 인터페이스이다
    * 자세히는 `BeanFactory` 와 `ApplicationContext` 로 구분해서 스프링 컨테이너라고 해야 하지만, 대부분 `BeanFactory` 를 직접 사용하는 경우가 없다
* 스프링 컨테이너는 XML 이나 어노테이션 기반으로 생성할 수 있다

#### 스프링 컨테이너의 생성 과정

1. 스프링 컨테이너 생성
    * 스프링 컨테이너를 생성할 때는 구성 정보를 지정해줘야 한다
2. 스프링 빈 등록
    * 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다
    * 빈 이름은 메서드 이름을 사용하나, `@Bean(name=xxx)` 와 같은 형태로 따로 지정해줄 수 있다
    * 빈 이름은 항상 다른 이름을 부여해야 한다 (같은 빈 이름이 존재하면 덮어씌워지는 등의 문제가 발생한다)
3. 스프링 빈 의존관계 설정
    * 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)한다
    * 스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다

### 스프링 빈 조회 - 상속관계

* 부모 타입으로 조죄하면, 자식 타입도 함께 조회된다
    * 이렇게 때문에 모든 자바 객체의 최고 부모인 `Object` 타입으로 조죄하면. 모든 스프링 빈을 조회한다
  
### BeanFactory 와 ApplicationContext

* BeanFactory
    * 스프링 컨테이너의 최상위 인터페이스
    * 스프링 빈을 관리하고 조회하는 역할을 담당
    * `getBean()` 을 제공한다
* ApplicationContext
    * BeanFactory 기능을 모두 상속받아 제공한다
    * 빈을 관리하고 검색하는 기능을 BeanFactory 가 제공하고, ApplicationContext 는 애플리케이션을 개발할 때 더 많은 기능을 제공한다
    * ApplicationContext 가 제공하는 기능
        * 메시지소스를 활용한 국제화 기능
        * 환경변수 - 로컬/개발/운영 등을 구분하여 처리
        * 애플리케이션 이벤트 - 이벤트를 발생하고 구독하는 모델을 편리하게 지원
        * 편리한 리소스 조회 - 파일/클래스패스/외부 등에서 리소스를 편리하게 조회
* 정리
    * ApplicationContext 는 BeanFactory 의 기능을 상속받는다
    * ApplicationContext 는 빈 관리지능 + 편리한 부가 기능을 제공한다
    * BeanFactory 를 직접 사용할 일은 거의 없다.
        * 부가기능이 포함된 ApplicationContext 를 사용한다
    * BeanFactory 나 ApplicationContext 를 스프링 컨테이너라고 한다

### 다양한 설정 형식 지원

* 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다
  * Java/XML/Groovy 등
  
#### Annotation 기반 자바 코드 설정 사용

* `new AnnotationConfigApplicationContextr(xxx.class)` 와 같은 형태로 사용한다
* `AnnotationConfigApplicationContext` 클래스를 사용하면서 자바 코드로된 설정 정보를 넘기면 된다

#### XML 설정 사용

* 최근에는 스프링 부트를 많이 사용하면서 XML 기반의 설정은 잘 사용하지 않는다
    * 많은 레거시 프로젝트 들이 XML 로 되어있고, XML 로 사용시 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점이 존재한다
* `GenericXmlApplicationContext` 를 사용하여 `xml` 설정 파일을 넘기면 된다

### 스프링 빈 설정 메타 정보 - BeanDefinition

* 스프링은 다양한 설정 형식을 지원하는 중심에는 `BeanDefinition` 이라는 추상화가 존재한다
    * 이는 **역할과 구현을 개념적으로 나눈 것**이다
        * XML/Java 등을 읽어서 BeanDefinition 을 만들면 된다
* `BeanDefinition` 을 빈 설정 메타정보라고 한다
    * `@Bean`/`<bean>` 당 각각 하나씩 메타 정보가 생성된다
* 스프링 컨테이너는 이러한 메타정보를 기반으로 스프링 빈을 생성한다
* `AnnotationConfigApplicationContext` 는 `AnnotatedBeanDefinitionReader` 를 사용해서 java 설정 파일을 읽고 `BeanDefinition` 을 생성한다
* `GenericXmlApplicationContext` 는 `XmlBeanDefinitionReader` 를 사용해서 xml 설정 파일을 읽고 설정 정보를 읽고 `BeanDefinition` 을 생성한다
* 새로운 형식의 설정 정보가 추가되면, xxxBeanDefinitionReader 를 만들어 `BeanDefinition` 을 생성하면 된다

#### BeanDefinition 정보

* BeanClassName: 생성할 빈의 클래스 명 (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
* factoryBeanNAme: 팩토리 역할의 빈을 사용할 경우
* factoryMethodNAme: 빈을 생성할 팩토리 메서드 지정
* Scope: 싱글톤(기본값)
* lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
* InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
* DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
* Constructor arguments, Properties: 의존관계 주입에서 사용 (자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

#### BeanDefinition 정리

* BeanDefinition 을 직접 설정해서 스프링 컨테이너에 등록할 수 있다
    * 하지만 BeanDefinition 을 직접 정의하거나 사용할 일은 거의 없다
* BeanDefinition 에 대해 너무 깊이있게 이해보다는 스프링이 다양한 형태의 설정 정보를 BeanDefinition 으로 추상화해서 사용하는 것 정도만 이해하면 된다

### 웹 애플리케이션과 싱글톤

* 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생하였다
    * 대부분의 스프링 애플리케이션은 웹 애플리케이션이다
    * 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다
    * `AppConfig` 의 경우 요청을 할 때 마다 객체를 새로 생성한다
    * 이러한 문제점을 해결하기 위한 해결방안으로, 해당 객체가 1개만 생성되고 공유되도록 설계하면 된다 (싱글톤 패턴)

### 싱글톤 패턴

* 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴이다
    * 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다
    * 즉, `private` 생성자를 사용해서 외부에서 임의로 `new` 를 통해 생성하지 못해야 한다
* 싱글톤 패턴 문제점
    * 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다
    * 의존관계상 클라이언트가 구체 클래스에 의존한다 (DIP 위반)
    * 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다
    * 테스트 하기가 어렵다
    * 내부 속성을 변경하거나 초기화 하기 어렵다
    * private 생성자로 자식 클래스를 만들기 어렵다
    * 결론적으로 유연성이 떨어지며, 안티패턴으로 불리기도 한다

### 싱글톤 컨테이너

* 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다
* 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리한다
* 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다
    * 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다
* 스프링 컨테이너의 이러한 기능 때문에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다
    * 싱글톤 패턴을 위한 추가적인 코드가 필요없다
    * DIP, OCP, 테스트, private 생성자로부터 자유롭게 싱글톤을 사용할 수 있다

### 싱글톤 방식의 주의점

* 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful) 하게 설계하면 안된다
* 무상태(stateless)로 설계해야 한다
    * 특정 클라이언트에 의존적인 필드가 존재하면 안된다
    * 특정 클라이언트가 값을 변경할 수 있는 필드가 존재하면 안된다
    * 가급적 읽기만 가능해야 한다
    * 필드 대신 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다
* 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다
    * **공유필드는 항상 조심해야 하며, 스프링 빈은 항상 무상태로 설정해야 한다**

#### 싱글톤 정리

* `@Bean` 만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다
* `Configuration` 을 사용하면 스프링은 바이트코드 조작 라이브러리를 활용하여 해당 설정 파일을 상속받은 `CGLIB` 를 활용해서 스프링 빈을 등록한다
    * `CGLIB` 은 빈을 등록할 때, 기존에 등록된 빈을 호출할 경우 등록된 빈을 리턴한다
    * 즉, 싱글톤을 보장한다
    * 스프링의 설정을 할 때  `@=Configuration` 을 사용하자

### 컴포넌트  스캔과 의존관계 자동 주입 시작하기

* 등록해야 할 스프링 빈이 많아질수록 등록하기 힘들고, 설정 정보도 커지고, 누락하는 문제가 발생한다
    * 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다
    * 의존관계를 자동으로 주입하는 `@Autowired` 라는 기능을 제공한다
* `ComponentScan` 어노테이션을 사용하면 `@Component` 가 붙은 어노테이션 클래스를 스캔하여 스프링 빈으로 등록한다
    * 스프링 빈의 기본 이름은 클래스명을 사용하되, 맨 앞글자만 소문자를 사용한다
        * 빈 이름 기본 전략: MemberServiceImpl 클래스 -> memberServiceImpl
        * 빈 이름 직접 지정: @Component("memberService2") 와 같이 직접 지정할 수 있다
  * 각 컴포넌트 안에서 의존관계 주입이 필요한 곳에 `@Autowired` 어노테이션을 사용하면, 자동으로 여러개의 모든 의존관계를 주입받을 수 있다
      * 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다

### 탐색 위치와 기본 스캔 대상

* 탐색할 패키지의 시작 위치 지정이 가능하다
    * 모든 자바 클래스의 컴포넌트를 스캔하려면 시간이 오래 걸리기 때문에, 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다
  
```java
@ComponentScan(
        basePackages = "some.path"
)
```

* basePackages: 탐색할 패키지의 시작 위치를 지정
    * `basePackages = {"some.path1", "some.path2"}` 와 같이 여러개를 지정할 수 있다
* basePackageClasses: 지정한 클래스의 패키지를 탐색 시작 위로 지정
* 별도의 패키지를 지정하지 않으면, `@ComponentScan` 이 붙은 설정 정보 클래스와 패키지가 시작 위치가 된다
* 별도의 패키지를 지정하지 않고, 프로젝트 최상단에 두는 것을 권장하며 스프링 부트도 이러한 방법으로 기본적으로 제공된다
    * 기본적으로 `SpringBootApplication` 이라는 어노테이션이 스프링 부트 프로젝트 시작 루트에 있으며, 해당 어노테이션에 `@ComponentScan` 이 들어있다
  
#### 컴포넌트 스캔 기본 대상

* 컴포넌트 스캔은 아래 내용이 모두 스캔 대상에 포함된다
    1. `@Component`: 컴포넌트 스캔에서 사용
    1. `@Controller`: 스프링 MVC 컨트롤러에서 사용되며, 스프링 MVC 컨트롤러로 인식
    1. `@Service`: 스프링 비즈니스 로직에서 사용되며, 해당 어노테이션이 특별히 동작하는 것은 없으나 비즈니스 로직 구분을 할 때 해당 어노테이션이 있으면 쉽게 인식이 된다
    1. `@Repository`: 스프링 데이터 접근 계층에서 사용되며, 스프링 데이터 접근 계층으로 인식되고 데이터 계층의 예외를 스프링 예외로 변경해준다
    1. `@Configuration`: 스프링 설정 정보에서 사용되며, 스프링 설정 정보로 인식하고 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다
* 참고로 어노테이션은 상속관계라는 것은 없으며, 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니며, 스프링이 지원하는 기능이다

### 필터

* `includeFilters`: 컴포넌트 스캔 대상을 추가로 지정
* `excludeFilters`: 컴포넌트 스캔에서 제외할 대상을 지정
* FilterType 옵션
    1. ANNOTATION: 기본값, 어노테이션을 인식해서 동작한다
    1. ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다 (ex> `org.example.SomeClass`)
    1. ASPECTJ: AspectJ 패턴 사용 (ex> `org.example..*Service+`)
    1. REGEX: 정규 표현식 (ex> `org\.example\.Default.*`)
    1. CUSTOM: `TypeFilter` 이라는 인터페이스를 구현해서 처리 (ex> `org.example.MyTypeFilter`)
* 참고로 `@Component` 만으로도 충분하기 때문에, `includeFilters` 를 사용할 일은 거의 없다

### 중복 등록과 충돌

1. 자동 빈 등록 vs 자동 빈 등록
    * 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 이름이 같은 경우 스프링은 `ConflictingBeanDefinitionException` 예외가 발생한다
1. 수동 빈 등록 vs 자동 빈 등록
    * 수동 빈 등록과 자동 빈 등록에서 빈 이름이 충돌되면 수동 빈 등록이 우선권을 가지고 수동 빈이 자동 빈을 오버라딩을 한다
    * 하지만 개발자가 의도적으로 설정해서 이러한 결과가 만들어지는 경우보다, 설정이 꼬여서 발생되는 부분이 대부분이다
        * 이러한 상황에서 발생하는 버그는 찾기가 정말 힘들다
        * 최근 스프링 부트에서는 충돌 시 오류가 발생하도록 기본 값이 변경되었다

### 다양한 의존관계 주입 방법

* 의존관계 주입은 크게 4가지 방법이 존재한다
    1. 생성자 주입
    1. 수정자 주입(setter 주입)
    1. 필드 주입
    1. 일반 메서드 주입

#### 생성자 주입

* 생성자를 통해서 의존관계를 주입 받는 방법이다
* 특징
    * 생성자 호출시점에 1번만 호출되는 것을 보장한다
    * 불변, 필수 의존관계에 사용된다
    * 스프링 빈인 경우 **생성자가 1개인 경우에는 `@Autowired` 를 생략해도 자동 주입이 된다**
  
#### 수정자 주입

* 필드의 값을 변경하는 수정자 메서드인 setter 를 이용하여 의존관계를 주입한다
* 특징
    * 선택, 변경 가능성이 있는 의존관계에 사용
    * 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
        * 자바빈 프로퍼티는 과거부터 필드의 값을 직접 변경하지 않고, setXXX, getXXX 라는 메서드를 통해 읽기/수정을 하는 규칙
* 참고로 `@Autowired` 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다
    * 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)` 로 지정하면 된다

#### 필드 주입

* 필드에 바로 주입하는 방법이다
* 특징
    * 코드가 간결해지지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 존재한다
    * DI 프레임워크가 없으면 아무것도 할 수 없다
    * 아래와 같은 특별한 이유가 없다면 사용하지 말아야 한다
        * **애플리케이션의 실제 코드와 관계 없는 테스트 코드**
        * 스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용

#### 일반 메서드 주입

* 일반 메서드를 통해서 주입 받을 수 있다
* 특징
    * 한번에 여러 필드를 주입 받을 수 있다
    * 일반적으로 잘 사용하지 않는다

### 옵션 처리

* 주입할 스프링 빈이 없어도 동작해야 할 때가 있다
* `@Autowired` 만 사용하면 `required` 옵션의 기본값이 `true` 이기 때문에 자동 주입 대상이 없을 경우 오류가 발생한다
* 자동 주입 대상을 옵션으로 처리하는 방법
    1. `@Autowired(required = false)`: 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
    1. `org.springframework.lang.@Nullable`: 자동 주입할 대상이 없으면 null 이 입력
    1. `Optional<>`: 자동 주입할 대상이 없으면 `Optional.empty` 가 입력
  
### 생성자 주입을 선택해라!

* 과거에는 수정자, 필드 주입을 많이 사용하였으나, 최근 스프링을 포함한 DI 프레임워크 대부분 생성자 주입을 아래와 같은 이유로 권장한다
    * **불변**
        * 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료 시점까지 의존고나계를 변경할 일이 없다.
            * 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다 (불변해야 한다)
        * 수정자 주입을 사용하면 `setXXX` 를 public 으로 열어야 한다
            * 누군가 실수로 변경을 할 수 있으며, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계가 아니다
        * 생성자 주입은 객체를 생성할 때 1번만 호출되므로, 이후에 호출되는 일이 없다
            * 따라서 불변하게 설계할 수 있다
    * **누락**
        * `@Autowired` 가 프레임워크 안에서 동작할 때는 의존관계가 없으면 오류가 발생한다
        * 생성자 주입을 사용하면 주입 데이터를 누락 하였을 때 '컴파일 에러'가 발생한다
    * **final 키워드**
        * 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있으며, 생성자에서 값이 설정되지 않는 오류를 컴파일 시점에서 막아준다
        * 또한, 불변 객체임을 명시할 수 있다
        * 생성자 주입을 제외한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 `final` 키워드를 사용할 수 없다
* 정리
    * 생성자 주입 방식을 선택하기에는 여러가지 이유가 존재하지만, 프레임워크에 의존하지 않고 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다
    * 기본적으로 생성자 주입을 사용하고, 필드 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다
        * 생성자 주입과 수정자 주입은 동시에 사용할 수 있다
    * 항상 생성자 주입 방식을 선택하는게 좋으며, 옵션이 필요하다면 수정자 주입을 선택하고, 필드 주입은 사용하지 않는게 좋다

### 조회 빈이 2개 이상 문제

* `@Autowired` 는 타입으로 조회한다
    * `ac.getBean(xxx.class)` 와 같은 형태로 조회를 한다
    * 타입으로 조회하기 때문에 조회된 타입이 2개 이상일 경우 문제가 발생한다
        * `NoUniqueBeanDefinitionException` 오류가 발생한다
    * 이때 하위 타입으로 지정할 수 있지만, 하위 타입으로 지정하는 것은 DIP 를 위배하고 유연성이 떨어진다
    * 그리고 이름만 다르고 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안된다

#### @Autowired 필드명, @Qualifier, @Primary

* 조회 대상이 2개 이상일 때
    1. @Autowired 필드명 매칭
    1. @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 매칭
    1. @Primary 사용

##### @Autowired 필드 명 매칭

* `@Autowired` 는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름/파라미터 이름으로 빈 이름을 추가 매칭한다

##### @Qualifier

* `@Qualifier` 는 추가 구분자를 붙여주는 방법
    * 추가적인 방법을 제공할 뿐, 빈 이름을 변경하는 것이 아니다
* `@Qualifier` 로 주입할 때, 해당 이름으로 못찾을 경우 해당 이름의 스프링 빈을 추가로 찾는다
* 빈을 등록할 때도 `@Qualifier` 를 사용할 수 있다
* `@Qulifier` 를 사용하게 되면, 해당 주입이 필요할 때 마다 `@Qulifier` 를 붙여줘야 한다

##### @Primary

* 우선순위를 정할 수 있는 방법이며, `@Autowired` 시에 여러 빈이 매칭될 때 `@Primary` 가 우선권을 가지게 된다

### 조회한 빈이 모두 필요할 때 (List, Map)

* 의도적으로 해당 타입이 모두 필요할 수 있다

### 자동, 수동의 올바른 실무 운영 기준

* 편리한 자동 기능을 기본으로 사용하자
* 시간이 지날수록 스프링은 자동을 선호하는 추세이며, 스프링은 `@Component` 뿐 아니라 `@Controller`/`@Service`/`@Repository` 처럼 계층에 맞추어 일반적인 애플리케이션 로직을 자동으로 스캔할 수 있도록 지원한다
    * 최근 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고, 스프링 부트의 다양한 스프링 빈들도 조건이 맞으면 자동으로 등록되도록 설계되었다
* 설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것은 이상적이다.
    * 하지만, 스프링 빈을 하나 등록할 때 `@Component` 를 사용하게 아닌 `@Configuration` 설정 정보에 가서 `@Bean` 을 적고, 객체를 생성하고, 주입할 대상을 일일이 적어주는 과정은 상당히 번거롭다
    * 또한, 관리할 빈이 많아서 설정 정보가 커지면 설정 정보를 관리하는 것 자체도 부담이 된다
    * 결정적으로 자동 빈 등록을 사용해도 OCP, DIP 를 지킬 수 있다
* 하지만, 아래와 같은 상황에서는 수동으로 빈 등록을 하면 좋다
    * 애플리케이션은 업무 로직과 기술 지원 로직으로 나눌 수 있다
        * 업무 로직 빈: 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 레파지토리 등이 해당되며, 비즈니스 요구사항을 개발할 때 추가되거나 변경된다
        * 기술 지원 빈: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용되며, 데이터베이스 연결이나 공통 로그 처리 등과 같이 업무 로직을 지원하기 위한 하부 기술이나 공통 기술이 해당된다
    * 업무 로직의 경우 숫자도 많고, 컨트롤러/서비스/레파지토리 처럼 어느정도 유사항 패턴이 존재할 경우 자동 기능을 사용하는게 좋다
    * 기술 지원 로직은 업무 로직과 비교해 수가 매우 적고, 애플리케이션 전반에 걸쳐 광범위하게 영향을 미치며, 기술 지원 로직에 문제가 발생하면 파악하기가 어렵기 때문에 가급적 수동 빈 등록을 사용해서 명확하게 들어내느 것이 좋다
* 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다
* 비즈니스 로직 중에서 다형성을 적극 활용할 때
    * 의존관계 자동 주입을 사용할 때, 어떤 빈들이 주입될지, 각 빈들의 이름이 무엇일지 코드만 보고 한번에 파악하기 어려운 경우가 있다
    * 내가 개발한 코드가 아닌 다른 사람 또는 다른 사람이 내가 개발한 코드를 볼 때는 더욱 파악하기가 어려울 수 있다
    * 바로 파악하기 어려울 수 있으므로, 수동으로 빈을 등록하거나 자동으로 등록시 특정 패키이에 같이 묶어 두는게 좋다
* 스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외이다
    * 스프링 자체를 잘 이해하고 스프링의 의도대로 잘 사용하는 것이 중요하다
    * `DataSource` 와 같은 데이터베이스 연결에 사용하는 기술 지원 로직까지 내부에서 자동으로 등록하는데, 이러한 부분은 메뉴얼을 참고하여 스프링 부트가 의도한 대로 편리하게 사용하면 된다
    * 하지만 스프링 부트가 아니라 직접 지원 객체를 스프링 빈으로 등록한다면 수동으로 등록해서 명확하게 들어내는 것이 좋다
* **정리**
    1. 편리한 자동 기능을 기본으로 사용하자
    1. 직접 등록하는 기술 지원 객체는 수동 등록하는게 좋다
    1. 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민하자

### 빈 생명주기 콜백

* 데이터베이스 커넥션 풀이나 네트워크 소켓과 같이 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 종료 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다
* 스프링 빈은 간단하게 **객체 생성 -> 의존관계 주입** 이라는 라이프사이클을 가진다
    * 스프링 빈은 객체를 생성하고 의존관계 주입이 다 끝난 다음에 필요한 데이터를 사용할 수 있는 준비가 완료된다
    * 초기화 작업은 의존고나계 주입이 모두 완료되고 난 다음에 호출되어야 한다
        * 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공한다
        * 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다
* 스프링 빈의 이벤트 라이프사이클
    * **스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸 콜백 -> 스프링 종료**
    * 초기화 콜백: 빈지 생성되고, 빈의 의존관계 주입이 완료된 후 호출
    * 소멸전 콜백: 빈이 소멸되기 직전에 호출

#### 객체의 생성과 초기화를 분리하자

* 생성자는 필수 정보를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다
* 반면에 초기화는 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다
* 따라서 생성자 안에 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다
    * 초기화 작업이 내부 값들만 변경하는 등의 단순한 경우에는 생성자에서 한번에 다 처리하는게 좋을 수 있다
    
#### 스프링이 제공하는 빈 생명주기 콜백

* 인터페이스 (InitializingBean, DisposableBean)
* 설정 정보에 초기화 메서드, 종료 메서드 지정
* @PostConstruct, @PreDestroy 애노테이션

##### 인터페이스 (InitializingBean, DisposableBean)

* `InitializingBean` 은 `afterPropertiesSet()` 메서드로 초기화를 지원한다
* `DisposableBean` 은 `destroy()` 메서드로 소멸을 지원한다
* 단점
    * 해당 인터페이스는 스프링 전용 인터페이스이며, 스프링 전용 인터페이스에 의존하게 된다
    * 초기화, 소멸 메서드의 이름을 변경할 수 없다
    * 코드를 변경할 수 없는 외부 라이브러리에 적용할 수 없다
    
##### 설정 정보

* 특징
    * 메서드 이름을 자율롭게 사용할 수 있다
    * 스프링 빈이 스프링 코드에 의존하지 않는다
    * 코드가 아닌 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다
* 종료 메서드 추론
    * `@Bean` 의 `destroyMethod` sms 기본값이 `(inferred) - 추론` 으로 등록되어 있는 아주 특별한 기능이 있다
    * 해당 기능은 `close`, `sshutdown` 이라는 이름의 메서드를 자동으로 호출해준다
    * 따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다
    * 추론기능을 사용하지 않으려면 `destoryMethod=""` 와 같이 빈 공백을 지정하면 된다
    
##### @PostConstruct, @PreDestroy 애노테이션

* 최신 스프링에서 가장 권장하는 방법
* 어노테이션 하나만 붙여서 사용하면 되므로 매우 편리하다
* `javax.annotation.PostConstruct` 라는 패키지인데, 이는 스프링에 종속적인 기술이 아닌 JSR-250 이라는 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 동작한다
* 컴포넌트 스캔과 잘 어울린다
* 유일한 단점은 외부 라이브러리에는 적용하지 못하며, 이때는 `@Bean` 의 기능을 사용하면 된다

##### 정리

* `@PostConstruct`/`@PreDestory` 어노테이션을 사용하자
* 외부 라이브러리를 초기화/종료해야 하면 `@Bean` 의 `initMethod`/`destroyMethod` 를 사용하자
