* js 는 클래스 기반이 아닌 prototype 에 기초한 객체 기반 언어이다.

### 클래스 기반 vs 프로토타입 기반

* 클래스 기반
  * 특정 객체군을 특징 짓는 모든 속성들을 정의한다.
    * 해당 객체군을 표현할 수 있는 특정 멤버를 지칭하는 것이 아닌 더 추상적인 것
  * 인스턴스는 클래스를 기반으로 실체화된 것
* 프로토타입 기반
  * 클래스와 인스턴스의 차이를 두지 않는다.
  * 원형(프로토타입)의 객체 개념을 가지고 있다.
  * 객체는 새로운 객체를 생성했을 때 초기 속성을 가질 수 있도록 하는 template 으로 사용된다.
  * 객체는 생성될 때 혹은 실행 시 자기 자신의 속성을 명시할 수 있다.
  * 객체들은 또 다른 객체를 생성하기 위한 프로토타입으로 연관지어 질 수 있으며 프로토타입으로부터 생성된 두번째 객체가 프로토타입인 첫번째 객체의 속성을 공유(접근)하는 것을 허용한다.

#### 클래스 정의

* 클래스의 인스턴스를 생성할 수 있는 생성자라는 특별한 메서드를 명시할 수 있다.
* 생성자는 해당 인스턴스의 초기 속성값을 지정할 수 있고 생성시점에 다른 처리를 할 수 있다.
* new 연산자와 함께 생성자를 통해 클래스의 인스턴스를 생성할 수 있다.
* js 는 비슷한 방법을 취하지만, 생성자 이외에 따로 클래스 정의를 가지고 있지 않다.
  * 특정 속성 및 속성값들을 가지고 객체를 생성하는 생성자 함수를 정의할 수 있다.
  * 특정 js 함수는 생성자로 사용 될 수 있다.
  * ECMAScript 2015 에서 클래스 선언이 새롭게 소개되었다.
    * 기존 js 프로토타입 기반 상속에 읽기 좋은 형식으로 바뀌었다.
    * js 에 새로운 객체 중심 상속 모델을 소개한 것은 아니다.

#### 하위 클래스와 상속

* 클래스를 정의할 때 이미 존재하는 클래스의 하위 클래스를 새로운 클래스로 지정할 수 있다.
* 하위 클래스는 부모 클래스의 모든 속성을 상속받으며 추가로 새로운 속성을 추가하거나 상속받은 속성을 수정할 수 있다.
* js 는 생성자 함수와 프로토타입 객체를 연결해 상속을 구현한다.

#### 속성의 추가 삭제

* 클래스 기반의 언어는 일반적으로 컴파일 시점에 클래스를 생성한 후 컴파일 시점 혹은 실행 시 해당 클래스의 인스턴스를 생성한다.
* 클래스가 한번 정의된 후 다시 컴파일 하지 않으면, 속성의 갯수나 형식을 변경할 수 없다.
* js 에서는 실행 시 객체의 속성을 추가, 삭제 할 수 있다.
  * 프로토타입으로 사용되는 객체에 속성을 추가하면, 프로토타입이 되는 객체들에도 새로운 속성이 추가가 된다.

#### 클래스, 프로토타입 차이점

| 클래스 기반 (자바 기준) | 원형 기반 (js 기준) |
| ---- | ---- |
| 클래스/인스턴스는 별개 | 모든 객체는 다른 객체로부터 상속 받는다 |
| 클래스 정의를 가지고 클래스를 생성하고 생성자 메서드로 인스턴스를 생성 | 생성자 함수를 가지고 객체군을 정의 및 생성 |
| new 연산자로 하나의 객체(인스턴스)를 생성 | 동일 |
| 이미 존재하는 클래스에 대한 하위 클래스를 정의함으로써 객체의 계층구조를 생성 | 하나의 객체를 생성자 함수와ㅓ 결합된 프로토타입에 할당함으로써 객체의 계층구조를 생성 |
| 클래스의 상속 구조에 따라 속성을 상속 받음 | 프로토타입 체인에 따라 속성을 상속 받음 |
| 클래스 정의는 모든 인스턴스의 모든 속성을 명시 <br/> 실행시 동적으로 속성을 추가할 수 없다 | 생성자 함수 혹은 프로토타입은 초기 속성들을 명시 <br/> 개별 객체 혹은 전체 객체군에 동적으로 속성을 추가/삭제 할 수 있다 |

### 객체 속성들

* new 연산자를 만나면 js 는 새로운 일반 객체를 생성하고 암묵적으로 내부의 `[[Prototype]](__proto__)` 속성의 값을 SomeObj.prototype 의 값으로 할당하며, 해당 객체를 this 키워드의 값으로써 생성자 함수를 SomObj 에 전달한다.
  * `[[Prototype]]` 속성은 속성값을 반환하기 위해 사용할 프로토타입 체인을 결정한다.
  * 속성들이 할당되면 js 는 새 객체를 반환하고 할당 구문에 의해 해당 변수에 객체를 할당한다.
* 이러한 절차는 프로토타입 체인으로부터 상속받는 속성의 값을 해당 객체 내부에 명시적으로 부여하진 않는다.
  1. 특정 속성의 값을 요청하면 js 는 먼저 해당 객체에 값이 존재하는지 확인
  2. 존재하면 해당 값을 반환
  3. 해당 객체에 값이 없으면 프로토타입 체인을 내장 `[[Prototype]]` 속성 `__proto__` 을 이용하여 확인
  4. 체인 상에 어떤 객체가 해당 속성의 값을 가지고 있다면 해당 값이 반환
  5. 찾는 속성이 proto 에도 없다면 undefined 를 반환한다.

```js
var someObj = new SomeObj();
```

#### 속성추가

* 생성자 함수가 제공하는 속성외에 다른 속성을 추가할 수 있다.
* `someObj.someNew = 'new';`
  * someObj 에 대해서는 someNew 라는 속성이 추가는 되지만, SomeObj 객체들은 someNew 라는 석성이 추가되지는 않는다.
* `SomeObj.prototype.someNew = 'new';` 형태로 prototype 에 추가하면 모든 객체에 해당 속성이 추가된다.

#### 속성 상속의 재고

```js
function Employee() {
    this.name = '';
    this.dept = 'general';
}
function WorkerBee() {
    this.projects = [];
}
WorkerBee.prototype = new Employee;

var amy = new WorkerBee;
// amy 객체는 프로젝트라는 자신만의 속성을 가진다.
// name, dept 는 amy 자체의 속성은 아니고, __proto__ 속성을 통해 가져 온 속성이다.

Employee.prototype.name = "Unknown";
// 모든 직원 인스턴스에 적용되지는 않는다.
// 직원 객체의 인스턴스를 생성할 때, 해당 인스턴스는 이름 속성에 대해 자신이 가지고 있는 값을 가진다.
// 새로운 직원 객체를 생성하여 Employee 의 프로토타입에 설정 할 때 WorkerBee.prototype 이 이름 속성에 대한 자신만의 값을 가진다는 의미이다.
// amy 객체의 이름 속성에 대해 WorkerBee.prototype 내에서 name 속성에 대한 amy 객체 자신의 값을 찾는다.
// 즉, Employee.prototype 까지의 프로토타입 체인을 검색하지 않는다.

// 실행시 객체의 속성 값을 변경하고 새로운 값이 모든 하위 객체들에게도 적용되도록 하려면, 객체의 생성자함수에서는 속성을 정의할 수 없다.
// 대신 생성자와 연결된 프로토타입에 추가할 수 있다.

function Employee () {
  this.dept = 'general';
}
Employee.prototype.name = '';

function WorkerBee () {
  this.projects = [];
}
WorkerBee.prototype = new Employee;

var amy = new WorkerBee;

Employee.prototype.name = 'Unknown';
// 이럴 경우 amy 의 name 은 변경이 된다.
// 즉, 해당 속성들을 생성자 함수 자체안에가 아닌 생성자의 프로토타입에 설정하면 실행 중 해당 속성의 값을 변경할 수 있다.
```

#### 인스턴스 관계 결정

* 프로토타입 체인에서의 검색
  * js 속성 검색은 객체 자신의 속성들을 먼저 살펴보고 해당 속성명을 찾지 못하면, `__proto__` 내에서 찾는다.
  * 이런 검색은 재귀적으로 진행된다.
* `__proto__` 는 객체가 생성이 될때 설정된다.
  * 해당 객체 속성은 모든 객체가 가진다. (Object 제외)
  * 해당 속성은 생성자의 프로토타입 속성의 값으로 설정된다.
  * new Foo() 는 `__proto__ == Foo.prototype` 인 객체를 생성한다.
* prototype 이라는 객체 속성은 모든 함수들이 가진다.
  * `__proto__` 속성과 `prototype` 객체를 비교하여 상속을 테스트 할 수 있다.
  * js 는 특정 객체가 함수 prototype 으로부터 상속 받는 객체일 경우 instanceof 를 통해 true 가 반환된다.

```js
var f = new Foo();
console.log(f instanceof Foo); //true
```
