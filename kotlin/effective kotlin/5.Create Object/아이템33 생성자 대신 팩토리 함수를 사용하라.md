## 생성자 대신 팩토리 함수를 사용하라

* 생성자를 통해 객체를 만들 수 있으나, 유일한 방법은 아니며 다양한 생성 패턴이 존재한다
    * 이러한 생성 패턴은 생성자로 직접 생성하지 않고 별도의 함수를 통해 생성한다
    * 생성자의 역할을 대신 해 주는 함수를 팩토리 함수라고 한다

```kotlin
fun <T> someCreationFactory(vararg elements: T): SomeObject<T> {
    val result = ...
    ...
    return result
}
// 위와 같이 생성자가 아닌 별도의 메서드를 통해 객체를 생성할 수 있으며, 이러한 것들을 팩토리 함수라고 한다
```

### 팩토리 함수의 장점

1. 팩토리 함수와 인자값에 이름을 붙여서 어떠한 값으로 어떠한 객체를 생성하는지 설명을 할 수 있다
    * 이를 통해 동일한 파라미터 타입을 가지는 생성자의 충돌을 줄일 수 있다
2. 생성자와 다르게 함수가 원하는 형태의 타입을 리턴할 수 있다
    * 이는 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용하게 사용할 수 있다
    * 대표적으로 `listOf` 라는 메서드는 인터페이스인 `List` 를 반환하고, 이는 플랫폼에 따라서 실제 리턴되는 객체가 달라지는 효과를 낼 수 있다
    * 인터페이스를 리턴한 것이므로 인터페이스만 잘 지킨다면, 어떠한 클래스도 잘 동작하게 되며, 이는 많은 자유를 가질 수 있게 된다
3. 생성자와 다르게 호출될 때마다 새 객체를 만들 필요가 없다
    * 이는 싱글톤 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위한 캐싱 메커니즘을 사용할 수 있음을 의미한다
    * 상황에 따라서 `null` 을 리턴하는 형태도 가능하다 (이는 2번의 내용과 비슷하다)
4. 팬토리 함수는 아직 존재하지 않는 객체를 리턴할 수 있다
    * 해당 특징 때문에 어노테이션 처리를 기반으로 하는 라이브러리에서는 팩토리 함수를 많이 사용한다
    * 프로젝트를 빌드하지 않고 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있다
5. 객체 외부에서 폭토리 함수를 만들면, 가시성을 원하는 대로 제어할 수 있다
6. 팩토리 함수는 인라인으로 만들 수 있고, 파라미터들을 `reified` 로 만들 수 있다
7. 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들 수 있다
8. 생성자는 즉시 슈퍼 클래스 또는 기본 생성자를 호출해야 하지만(생성자 블록 제일 최상위에), 팩토리 함수는 원하는 때에 생성자를 호출할 수 있다

### 팩토리 함수의 제약(?)

* 서브 클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브 클래스를 만들어 낼 수 없다
* 하지만 이는 서브 클래스에도 팩토리 함수를 만들어서 처리하면 된다

```kotlin
class SomeSubObject: SomeObject<Int>() {
    constructor(vararg ints: Int): someCreationFactory(*ints)
    // 오류
    
    fun someCreationIntFactory(vararg elements: Int): SomeObject {
        ...
        val result = someCreationFactory(*elements)
        ...
        
        return result
    }
    // 위와 같이 서브 클래스에도 생성자 팩토리를 생성하면, 상위 클래스의 팩토리 메소드를 사용할 수 있다
}
```

### Companion 객체 팩토리 함수

* 팩토리 함수를 정의하는 가장 일반적인 방법

```kotlin
class SomeObject<T> {
    ...
    
    companion object {
        fun <T> of(vararg elements: T): SomeObject<T> { ... }
    }
}

val someObject = SomeObject.of(1,2,3)
```

* 이는 Java 의 정적 팩토리 함수와 같고, C++ 에서 이름을 가진 생성자와 같다

```kotlin
interface MyObject<T> {
    ...
    
    companion object {
        fun <T> of(vararg elements: T): MyObject<T> { ... }
    }
}
// 위와 같이 코틀린에서 인터페이스에서도 구현이 가능하다
```

* 팩토리 함수는 굉장히 강력한 객체 생성 방법이다
* 생성자와 팩토리 메서드 둘 중 하나만 사용하라는 의미는 아니다
* 팩토리 함수는 기본 생성자가 아닌 추가적인 생성자와 경쟁 관계이다
    * 많은 코틀린 프로젝트에서 추가적인 생성자보다 팩토리 함수를 많이 사용한다

#### companion 활용

* companion 객체는 인터페이스를 구현할 수 있으며, 클래스를 상속받을 수 있다
* 추상 companion 객체 팩토리는 값을 가질 수 있으며, 캐싱을 구현하거나 테스트를 위한 가짜 객체를 생성할 수 있다

```kotlin
abstract class SomeFactory {
    abstract fun getInstance(some: Some): Something
    ...
}

class Foo {
    ...

    companion object : SomeFactory() {
        override fun getInstance(some: Some): Something {
            ...
        }
    }
}
// 위와 같이 companion 객체를 만드는 팩토리 함수를 만들 수 있다
```

#### 일반적인 팩토리 메소드 이름 설명

* `from`: 파라미터를 하나 받고, 같은 타입의 인스턴스 하나를 리턴하는 타입 변환 함수를 나타낸다
* `of`: 파라미터를 여러개 받고, 이를 통합해서 인스턴스를 만들어 주는 함수
* `valueOf`: `from` 또는 `of` 와 비슷한 기능을 하면서, 의미를 조금 더 쉽게 읽을 수 있도록 이름을 붙인 함수
* `instance` 또는 `getInstance`: 싱글턴으로 인스턴스 하나를 리턴하는 함수이며, 아규먼트가 존재하면 해당 아규먼트를 기반으로 인스턴스를 리턴한다
* `createInstance` 또는 `newInstance`: `getInstance` 처럼 동작하나, 싱글턴이 적용도지 않고 함수를 호출할 때마다 새로운 인스턴스가 생성된다
* `getType`: `getInstance` 처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용되는 이름이며, 타입은 팩토리 함수에서 리턴하는 타입이다
* `newType`: `newInstance` 처럼 동작하지만, 팩토리 함수가 다른 클래스에 있을 때 사용되는 이름

### 확장 팩토리 함수

* 이미 companion 깨체가 존재하고, 해당 객체의 함수처럼 사용할 수 있는 팩토리 함수를 만들어야 하지만, companion 객체를 직접 수정할 수 있는 경우가 존재한다
    * 이럴때 확장 함수를 활용할 수 있다
    
```kotlin
interface Tool {
    companion object { ... }
}

fun Tool.Companion.createBigTool( ... ): BigTool { ... }
// 위와 같이 companion 객체를 활용하여 확장 함수를 정의할 수 있다
```

* 이러한 방법을 활용하면, 외부 라이브러리를 확장할 수 있다
* 하지만 companion 객체를 확장하기 위해서는, companion 객체가 있어야만 한다

### 톱레벨 팩토리 함수

* `listOf`/`setOf`/`mapOf` 등과 같은 톱 레벨 팩토리 함수를 활용할 수 있다
    * `listOf(1,2,3)` vs `List.of(1,2,3)` 을 비교하면 `listOf` 가 더 읽기 쉽기 때문에 톱레벨 함수를 사용한다
* 이러한 톱 레벨 팩토리 함수는 굉장히 광범위하게 사용된다
* public 톱 레벨 함수는 모든 곳에서 사용할 수 있으므로, IDE 가 제공하는 팁을 복잡하게 만드는 단점이 존재한다
* 톱레벨 함수의 이름을 클래스 메서드 이름처럼 만들면, 다양한 혼란을 일으킬 수 있다

### 가짜 생성자

```kotlin
class A
val a = A()
// 코틀린의 생성자는 톱레벨 함수와 같은 형태로 사용된다

val reference: () -> A = ::A
// 따라서 위와 같이 톱레벨 함수처럼 참조될 수 있다
```

* 일반적인 사용자 관점에서 대문자로 시작하는 메서드는 생성자로 판단한다
* 함수도 대문자로 시작할 수 있지만, 이는 특수한 다른 용도로 사용된다
    * 대표적으로 `List`/`MutableList` 는 인터페이스이며, 이는 생성자를 가질 수 없지만, 다음과 같은 형태로 생성자처럼 사용할 수 있다
    ```kotlin
    List(4) { "User$it" }
    // 이러한 톱레벨 함수는 생성자처럼 보이고, 생성자처럼 작동하며, 팩토리 함수와 같은 모든 장점을 가진다
    // 위와 같은 메서드를 톱레벨 함수라고 잘 모르므로, 이러한 것을 가짜 생성자라고 부른다
    ```
* 가짜 생성자를 생성하는 이유
    1. 인터페이스를 위한 생성자를 만들고 싶을 때
    2. `reified` 타입 아규먼트를 가지게 하고 싶을 때
* 가짜 생성자는 결국 생성자 처럼 동작해야 한다
    * 캐싱, nullable 타입 리턴, 서브크래스 리턴 등의 기능을 포함하고 싶다면, companion 객체 팩토리 메서드와 같이 다른 이름을 가진 팩토리 함수를 사용하는 것이 좋다

```kotlin
class Tree<T> {
    companion object {
        operator fun <T> invoke(size: Int, generator: (Int) -> T): Tree<T> { ...}
    }
}

Tree(1) { "$it" }
// 위와 같이 invoke 연산자를 가지는 companion 객체를 사용하면 가짜 생성자와 비슷한 결과를 얻을 수 있으나,
// 이러한 방식은 거의 사용되지 않고 추천하지 않는다 ('아이템 12: 연산자 오버로드는 의미에 맞게 하라' 를 위배한다)
// invoke 는 호출한다라는 의미이고, 이는 객체 생성과 의미가 다르다
```

#### 팩토리 함수의 정리

* 코틀린에서 팩토리 함수를 만들 수 있는 다양한 방법들을 제공하며, 각 방법들은 여러 특징을 가지고 있으며, 잘 파악하고 사용해야 한다
* 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 방법이다
    * 이러한 스타일은 자바의 정적 팩토리 메서드 패턴과 윺사하다
