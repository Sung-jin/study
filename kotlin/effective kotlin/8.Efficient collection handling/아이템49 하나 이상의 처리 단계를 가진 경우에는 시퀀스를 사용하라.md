## 하난 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

* Sequence 는 지연처리되며, 시퀀스 처리 함수들을 사용하면 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다
    * 최종적인 계산은 toList/count 등의 최종 연산이 이루어질 때 수행된다
* Iterable 은 처리 함수를 사용할 때마다 연산ㄴ이 이루어지고 List 가 만들어진다
* 컬렉션 처리 연산은 호출할 때 연산이 이루어지고, 시퀀스 처리 함수는 최종 연산이 이루어지기 전까지 각 단계에서 연산이 이뤄지지 않는다
* 시퀀스 지연 처리의 장점
    1. 자연스러운 처리 순서를 유지한다
    2. 최소한으로 연산하다
    3. 무한 시쿼스 형태로 사용할 수 있다
    4. 각 단계에서 컬렉션을 만들어 내지 않는다
    
### 순서의 중요성

* 시퀀스 처리는 요소 하나하나에 지정한 연산을 한꺼번에 적용하며, 이를 element-by-element 또는 lazy order 라고 한다
* 이터러블은 요소 전체를 대상으로 연산을 진행하며, 이를 step-by-step 또는 eager order 라고 한다

```kotlin
sequenceOf(1,2,3)
    .filter { prirnt("F$it, "); it % 2 == 1 }
    .map { prirnt("M$it, "); it * 2 }
    .forEach { print("E$it, " ) }
// F1, M1, E2, F2, F3, M3, E6

listOf(1,2,3)
    .filter { prirnt("F$it, "); it % 2 == 1 }
    .map { prirnt("M$it, "); it * 2 }
    .forEach { print("E$it, " ) }
// F1, F2, F3, M1, M3, E2, E6
```

* 컬렉션 처리 함수가 아닌 고전적인 반복문과 조건물을 활용할 경우 element-by-element 와 같이 처리가 된다

```kotlin
for (e in listOf(1,2,3)) {
    print("F$e, ")
    if (e % 2 == 1) {
        print("M$e, ")
        val mapped = e * 2
        print("E$mapped, ")
    }
}
// F1, M1, E2, F2, F3, M3, E6
```

### 최소 연산

* 컬렉션에서는 중간 연산이라는 개념이 없고, 시퀀스에는 중간 연산이라는 개념이 존재한다
    * 즉, 시퀀스에서는 중간에 원하는 요소에만 원하는 처리를 적용할 수 있다
    
```kotlin
(1..10).asSequence()
    .filter { print("F$it, "); it % 2 == 1 }
    .map { print("M$it, "); it * 2 }
    .find { it > 5 }
// F1, M1, F2, F3, M3,

(1..10)
    .filter { print("F$it, "); it % 2 == 1 }
    .map { print("M$it, "); it * 2 }
    .find { it > 5 }
// F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, M1, M3, M5, M7, M9
```

* 위와 같이 중간 처리 단계를 모든 요소에 적용할 필요가 없다면, 시퀀스를 사용하는 것이 좋다

### 무한 시퀀스

* 시퀀스는 최종 연산이 발생하기 전까지는 어떠한 처리도 하지 않으므로, 무한 시퀀스를 만들어 필요한 부분까지만 값을 추출하는 것도 가능하다
    * 무한 시퀀스를 만드는 일반적인 방법으로는 `generateSequence`/`sequence` 를 사용하면 된다
    
```kotlin
generateSequence(1) { it + 1 }
    .map { it * 2 }
    .take(10)
    .forEach { print("$it, ") }

val fibonacci = sequence {
    yield(1)
    // yield 를 통해 값을 하나씩 생성한다
    var current = 1
    var prev = 1
    while (true) {
        yield(current)
        val temp = prev
        prev = current
        current += temp
    }
}

print(fibonacci.take(10).toList())
// [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

* 무한 시퀀스를 사용할 때 값을 몇개 활용할지 지정하지 않으면 무한하게 반복한다
    * take 를 이용하여 활용할 값이 수를 지정하거나, find/any/all/none/indexOf 등과 같이 이부 요소만 선택하는 종결 연산을 활용해야 한다

### 각각의 단계에서 컬렉션을 만들어 내지 않음

* 표준 컬렉션 처리 함수는 단계마다 새로운 컬렉션을 만들어 내며, 만들어진 컬렉션을 활용하거나 저장할 수 있는 것은 장점이지만, 그만큼 공간이 차지된다는 단점이 존재한다
    * 즉, 무거운 컬렉션을 처리할 때 굉장히 큰 비용이 들어가게 된다
* 컬렉션 처리의 각각의 단계에서 새로운 컬렉션을 만드는 데는 비용이 들어가며, 크기가 큰 요소를 처리할수록 비용이 커진다
* 처리 단계가 한단계라면, 컬렉션 처리와 시퀀스 처리의 차이가 크지 않으나, 단계가 많아질수록 차이가 커지므로 시퀀스 처리를 활용하는 것이 좋다

### 시퀀스가 빠르지 않은 경우

* 컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀀스를 사용해도 빨라지지 않는다
    * 유일한 예로는 코틀린 stdlib 의 sorted 가 있다
    * sorted 는 Sequence 를 List 로 변환한 뒤 sort 를 사용하여 처리하며, 이러한 변환 떄문에 컬렉션의 처리보다 느려진다
    * iterable 도 컬렉션 또는 배열이 아니므로, 변환에 따른 성능 저하가 존재한다
* 무한 시퀀스에서 sorted 를 적용하면 무한 반복에 빠지는 문제가 발생한다

```kotlin
generateSequence(0) { it + 1 }.take(10).sorted().toList()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,]
generateSequence(0) { it + 1 }.sorted().take(10).toList()
// 종료되지 않고 무한반복에 빠진다
```

* sorted 의 경우 Sequence 보다 Collection 에서 빠른 희귀한 예이며, 다른 처리는 모두 Sequence 가 빠르다
    * 즉, 여러가지 결합된 경우에는 시퀀스를 사용하는 것이 좋다
    
### 자바 스트림의 경우

* Java 8 의 스트림도 lazy 하게 동작하며, 마지막 처리 단계에서 연산이 일어나지만 코트린의 시퀀스와는 다음과 같은 차이점이 존재한다
    1. 코틀린의 시퀀스가 더 많은 처리 함수를 가지고 있다
    2. 자바 스트림은 병렬 함수를 사용하여 병렬 모드로 실행할 수 있다
        * 이는 멀티 코어 환경에서 굉장히 큰 성능 향상을 가져오나, 몇가지 결함이 존재하여 잘 사용해야 한다
    3. 코틀린의 시퀀스는 코틀린/JVM, 코틀린/JS, 코트린/네이티브 등의 일반적인 모듈에서 모두 사용이 가능하다
        * Java 의 스트림은 코틀린/JVM 에서만 사용 가능하며, JVM 8 버전 이상이어야 한다
    
### 코틀린 시퀀스 디버깅

* 자바 스트림의 경우 Java Stream Debugger 라는 플러그인이 존재한다
* 코틀린 시퀀스의 경우 Kotlin Sequence Debugger 라는 플러그인이 존재하며, 이는 현재 Kotlin 플러그인에 통합되어 있다

## 정리

* 컬렉션과 시퀀스는 같은 처리 메서드를 지원하며, 사용하는 형태가 거의 비슷하다
* 일반적으로 데이터를 컬렉션에 저장하므로, 시퀀스 처리를 하려면 시퀀스로 변환하는 과정이 필요하다
    * 최종적인 결과를 원하는 경우가 많으므로, 시퀀스를 다시 컬렉션으로 변환하는 과정도 필요하다
* 시퀀스는 lazy 하게 처리되며, 이로인해 다음과 같은 장점이 발생한다
    1. 자연스러운 처리 순서를 유지한다
    2. 최소한만 연산한다
    3. 무한 시퀀스 형태로 사용할 수 있다
    4. 각각의 단계에서 컬렉션을 만들어 내지 않는다
* 따라서 무거운 객체나 여러 단계의 처리가 필요하면 컬렉션 처리보다는 시퀀스 처리가 훨씬 효율적이고 빠르다
