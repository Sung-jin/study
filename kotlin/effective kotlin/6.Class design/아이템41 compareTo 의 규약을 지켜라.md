## compareTo 의 규약을 지켜라

* compareTo 는 Any 에 있는 메서드가 아니며, 수학적인 부등식으로 변환되는 연산자이다
```kotlin
obj1 > obj2 // obj1.compareTo(obj2) > 0
obj1 < obj2 // obj1.compareTo(obj2) < 0
obj1 >= obj2 // obj1.compareTo(obj2) >= 0
obj1 <= obj2 // obj1.compareTo(obj2) <= 0
// 위와 같이 변한다
```

* compareTo 메서드는 `Comparable<T>` 인터페이스에도 들어 있다
    * 해당 인터페이스를 구현하거나 compareTo 연산자 메서드를 가지고 있다는 의미는, 해당 객체가 어떤 순서를 가지고 있으므로 비교할 수 있다는 의미이다
* compareTo 는 다음과 같이 동작해야 한다
    * 비대칭적 동작
        * a >= b 이고 b >= a 이면, a == b 이여야 한다
        * 비교와 동등성 비교에 어떠한 관계가 있어야 하며, 서로 일관성이 있어야 한다
    * 연속적 동작
        * a >= b 이고 b >= c 라면, a >= c 이어야 한다
        * a > b 이고 b > c 라면, a > c 이어야 한다
        * 이러한 동작을 하지 못하면, 요소 정렬이 무한 반복에 빠질 수 있다
    * 코넥스적 동작(connex relation)
        * 두 요소는 어떤 확실한 관계를 가지고 있어야 한다
        * a >= b 또는 b >= a 중에 적어도 하나는 항상 true 이어야 한다
        * 두 요소 사이에 관계가 없으면, 퀵 정렬과 삽입 정렬 등의 고전적인 정렬 알고리즘을 사용할 수 없다
    
### compareTo 를 따로 정의해야 할까?

* 코틀린에서 compareTo 를 따로 정의해야 하는 상황은 거의 없다
* 일반적으로 어떠한 프로퍼티 하나를 기반으로 순서를 지정하는 것으로 충분하다
    * 여러 프로퍼티를 기반으로 정렬해야 한다면, `sortedWith` 함수를 사용하면 된다
    * 해당 함수는 `compareBy` 를 활용하여 comparator 를 만들어서 사용한다
    
```kotlin
names.sortedWith(compareBy({ it.surname }, { it.name }))
// surname 으로 정렬을 하고, surname 이 같다면 name 까지 비교하여 정렬한다
```

* Comparable<User> 를 구현하는 형태로 만들 수 있으며, 이때는 특정 프로퍼티를 기반으로 정렬하게 하면 된다
    * 만약 절대적인 기준이 없다면, 비교를 하지 못하게 만드는 것도 좋다
* 문자열과 알파벳, 숫자 등은 순서가 있다 (내부적으로 Comparable<String> 을 구현하고 있다)
    * 알파벳 등은 부호 비교시 가독성이 많이 떨어진다
    * 반대로 측정 단위, 날짜, 시간 등은 자연스러운 순서를 가지며, 또한 부등호로 비교는 자연스럽다
* 객체가 자연스러운 순서인지 확실하지 않다면 비교기를 사용하는 것이 좋다
    * 자주 사용한다면, 클래스에 companion 객체로 만들어 두는 것도 좋다
    
### compareTo 구현하기

* compareTo 를 구현할 때 유용하게 활용할 수 있는 톱레벨 함수가 있다
    * 두 값을 단순하게 비교하기만 한다면, compareValues 함수를 활용하면 된다
    * 더 많은 값을 비교하거나 선택기를 활용하여 비교하고 싶다면, compareValuesBy 를 사용하면 된다
* 이 함수는 비교기를 만들 때 도움이 된다
* 논리를 구현해야 하는 경우 다음 값을 리턴해야만 한다
    * 0: 리시버와 other 가 같은 경우
    * 양수: 리시버가 other 보다 큰 경우
    * 음수: 리시버가 other 보다 작은 경우
* 이를 구현한 뒤, 해당 함수가 비대칭적 동작/연속적 동작/코넥스적 동작 여부를 확인해야 한다
