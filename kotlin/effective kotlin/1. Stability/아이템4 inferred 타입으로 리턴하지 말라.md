## inferred 타입으로 리턴하지 말라

* 코틀린의 타입 추론(type inference) 은 JVM 세계에서 가장 널리 알려진 코틀린의 특징이다
    * Java10 에서 코틀린과 비교하여 몇가지 제약사항이 추가된 타입 추론을 도입하였다
* 타입 추론시 위험사항이 존재하며, 이러한 위험사항을 피하기 위해서는 할당때 inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다는 것을 기억해야 한다
    * 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다
    ```kotlin
    open class Animal
    class Zebra: Animal()
    
    fun main() {
        var animal = Zebra()
        animal = Animal() // Type mismatch 오류 발생
    }
    ```
* 위와 같은 사항은 일반적인 경우에 문제가 되지 않으며, 원하는 타입보다 제한된 타입이 설정되었다면 타입을 명시적으로 지정하여 문제를 해결할 수 있다
    ```kotlin
    var animal: Animal = Zebra() // 원하는 타입으로 설정하면 아래와 같이 Animal 로 변경하여도 type mismatch 에러가 발생하지 않는다
    animal = Animal()
    ```
    * 하지만 이는 라이브러리 또는 모듈을 조작할 수 없는 경우에 이러한 문제를 간단하게 해결할 수 없다
    * 또한 이러한 경우에 inferred 타입을 노출하면 위험한 일이 발생할 수 있다
    ```kotlin
    interface CarFactory {
        fun produce(): Car
    }
  
    val DEFAULT_CAR: Car = Fiat126P()
    // 위와 같이 CarFactory 인터페이스와 기본 자동차가 존재하지만,
    // 대부분의 공장에서 Fiat126P 를 생상하여 인터페이스의 값을 기본값으로 변경한다면
  
    interface CarFactory {
        fun produce() = DEFAULT_CAR
        // 위와 같이 변경이 되고, 리턴 타입이 없으므로 타입 추론에 의해 자동차 타입으로 지정될 것을 예상하여 명시적으로 지정하지 않아도 된다 판단하고
    }
  
    val DEFAULT_CAR = Fiat126P()
    // 와 같이 변경을 하면,
    // CarFactory 에서는 이제 Fiat126P 외의 자동차를 생성할 수 없게 된다
    ```
* 위와 같은 상황이 발생할 수 있으며, 리턴 타입은 API 를 잘 모르는 사람에게 전달할 수 있는 중요한 정보이므로 외부에서 확인할 수 있도록 명시적으로 지정해 주는 것이 좋다

## 정리

* 타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 가지고 있으면 된다
* 타입은 굉장히 중요한 정보이므로 숨기지 않는 것이 좋다
* 안전을 위해 외부 API 를 만들 떄는 반드시 타입을 지정하고 지정한 타입을 특별한 이유와 확신이 없다면 제거하지 ㅁ라아야 한다
* inferred 타입은 프로젝트가 진절될 때 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있음을 기억해야 한다
