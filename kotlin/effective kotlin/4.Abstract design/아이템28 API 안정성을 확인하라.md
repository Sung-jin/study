## API 안정성을 확인하라

* 안정적이고 표준적인 API 를 선호하는 주요 이유는 다음과 같다
    1. API 가 변경되고 개발자가 이를 업데이트하였따면, 여러 코드를 수동으로 업데이트해야 한다
        * 변경에 대응하거나 다른 대안을 찾는 것은 매우 어려운 일이다
        * 라이브러리의 작은 변경은 이를 활용하는 다른 코드들의 많은 부분을 변경하게 만들 수 있다
        * 그래서 라이브러리가 변경되어도 이전 라이브러리를 유지하는 경우가 많지만, 이러면 버그와 취약성 등이 발생할 수 있으며 해당 버전이 더이상 지원하지 않게 될 수도 있다
        * 결론적으로 안정적인 라이브러리로 업데이트하는 것을 두려워하는 것은 매우 좋지 않은 상황이다
    2. 사용자가 새로운 API 를 배워야 하지만, 이는 힘들고 피하게 되지만 오래된 지식 때문에 보안 문제가 발생할 수 있다
        * 좋은 API 를 한번에 설계할 수는 없고, 계속해서 개선하기 위해 변경을 해야 한다
        * 간당한 방법은 작성자가 불안정한 API 를 명확하게 알려주어야 한다
        * 많은 버저닝 시스템이 있지만, 일반적으로 시멘틱 버저닝을 사용한다
            * `Major`.`Minor`.`Patch`
            * Major: 호환되지 않는 수준의 API 변경을 의미하며, 0인 경우 초기 개발 전용 버전을 의미
            * Minor: 이전 변경과 호환되는 기능을 추가
            * Patch: 간단한 버그 수정
    
### 안정성 여부

* 안정적인 API 에 새로운 요소를 추가할 때, 아직 해당 요소가 안정적이지 않다면 다른 브랜치에 해당 요소를 두는 것이 좋다
* 일부 사용자가 이를 사용하도록 허용하려면 `Experimental` 메타 어노테이션을 사용하여 사용자들에게 사용은 할 수 있으나, 안정적이지 않다는 것을 알려주는 것이 좋다
    * `Experimental` 어노테이션을 붙이면, 사용할 수 있으나 설정된 레벨에 따라서 경고 또는 오류가 출력된다
    * 이러한 실험적 기능은 언제든지 변경이 될 수 있으니 이러한 요소를 오랫동안 실험적 요소로 두는 것을 두려워 할 필요가 없다
* 안정적인 API 의 일부를 변경해야 한다면, 전환하는데 시간을 두고 `Deprecated` 어노테이션을 활용하여 사용자에게 미리 알려줘야 한다ㅏ
    * 직접적인 대안이 있다면, IDE 가 자동으로 전환을 할 수 있게 `ReplaceWith` 을 붙여주는 것도 좋다
    * `Deprecated` 로 변경하였다면, 사용자는 이러한 변경에 적응할 시간을 주어야 사용자가 새로운 API 를 적응핟고 변경을 할 시간이 필요하다
    
```kotlin
@Experimental(level = Emerimental.Level.WARNING)
fun someExperimentalFunc() {}

@Deprecated("Use suspending getUsers instead", ReplaceWith("getUsers()"))
fun getUsers(callback: (List<User>) -> Unit) {}

fun getUsers() {}
```

## 정리

* 사용자는 API 의 안정성에 대해 알아야 하며, 안정적인 API 를 사용하는 것이 좋다
    * 안정적이라 생각했던 API 에 예상하지 못한 변경이 일어날때가 가장 나쁜 상황이다
* 모듈과 라이브러리르 만드는 사람과 사용하는 사용자들간의 커뮤니케이션이 중요하다
    * 커뮤나케이션은 버전 이름, 문서, 어노테이션 등을 통해 할 수 있다
* 안정적인 API 에 변경을 할때는 사용자가 적응할 충분한 시간을 줘야 한다
