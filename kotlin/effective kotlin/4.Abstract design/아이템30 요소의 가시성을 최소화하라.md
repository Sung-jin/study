## 요소의 가시성을 최소화하라

* API 를 설계할 때 간결한 API 를 선호하는 이유
    1. 작은 인터페이스는 배우기 쉽고 유지하기 쉽다
        * 기능이 많은 클래스보다 적은 클래스를 이해하는 것이 쉽고, 유지보수도 쉽다
    2. 변경을 가할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉽다
        * 일반적으로 공개적으로 노출되어 잇는 요소들은 공개 API 의 일부이며, 외부에서 사용이 가능하다
        * 이러한 부분을 변경하면, 해당 코드를 사용하는 모든 부분이 영향을 받는다
            * 이러한 변경은 신중하게 고려해야 하며, 변경할 경우에는 대체재를 제공해야 한다
        * 처음에는 작은 API 로 개발을 하도록 강제하는 것이 더 좋을 수 있다
    3. 클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없다
        * 클래스가 만족해야 하는 클래스의 상태에 대한 규약이 존재할 수 있으며, 이러한 규약을 모르는 사람이 클래스의 상태를 마음대로 변경할 수 있다면 클래스의 불변성이 무너질 가능성이 높다
        * 일반적으로 코틀린에서는 구체 접근자의 가시성을 제한하여 모든 프로퍼티를 캡슐화하는 것이 좋다
        * 의존하는 프로퍼티가 있을 경우, 객체 상태를 보호하는 것이 더 중요해진다
        * 가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있고, 프로퍼티의 상태를 더 쉽게 이해할 수 있다
            * 동시성을 처리할 때 중요하며, 상태 변경을 병렬 프로그래밍에서 문제가 되므로 많은 것을 제한할수록 병렬 프로그래밍에서 더 안전해진다

### 가시성 한정자 사용하기

* 내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면 가시성을 제한하면 된다
    * 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면, 가시성을 제한하여 외부에서 접근할 수 없게 만드는 것이 좋다
* 가시성 제한은 가시성 한정자를 활용하여 구현한다
    * public(디폴트): 어디에서나 접근 가능
    * private: 클래스 내부에서만 접근 가능
    * protected: 클래스와 서브클래스 내부에서만 접근 가능
    * internal: 모듈 내부에서만 볼 수 있다
* top-level 요소의 가시성 한정자
    * public(디폴트): 어디에서나 접근 가능
    * private: 같은 파일 내부에서만 접근 가능
    * internal: 모듈 내부에서만 접근 가능
* 모듈: 함께 컴파일되는 코틀린 소스를 의미하며, 다음과 같은 것을 의미한다
    * gradle 소스 세트
    * maven 프로젝트
    * 인텔리제이 IDEA 모듈
    * Ant 태스크 한 번으로 컴파일 되는 파일 세트
* 모듈이 다른 모듈에 의해 사용될 가능성이 있다면, internal 을 사용하여 공개하고 싶지 않은 요소를 숨길 수 있다
* 요소가 상속을 위해 설계되어 있고, 클래스와 서브클래스에서만 사용되게 만들고 싶다면 protected 를 사용하면 된다
* 동일한 파일 또는 클래스에서만 요소를 사용하고자 한다면, private 을 사용하면 된다
    * 참고로 코틀린은 지역적으만 사용되고 있는 요소는 private 으로 만드는 것이 좋다는 컨벤셔을 제공한다
* 위와 같은 규칙들은 데이터를 저장하도록 설계된 데이터 모델 클래스나 DTO 에는 적용하지 않는게 좋다
    * 데이터를 저장하도록 설계된 클래스는 숨길 이유가 없다
* 한가지 큰 제한은 API 를 상속할 때 오버라이드하여 가시성을 제한할 수 없다
    * 이는 서브클래스가 슈퍼클래스로도 사용될 수 있기 떄문이다
    * 이러한 사항때문에 상속보다는 컴포지션을 선호하는 대표적이 이유이다

## 정리

* 요소의 가시성은 최대한 제한적인 것이 좋다
* 다음과 같은 이유로 최대한 단순한것이 좋다
    * 인터페이스가 작을수록 이를 학습하고 유지보수하기 쉽다
    * 최대한 제한이 되어 있어야 변경이 쉽다
    * 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다
    * 가시성이 제한되면 API 의 변경을 쉽게 추적할 수 있다
