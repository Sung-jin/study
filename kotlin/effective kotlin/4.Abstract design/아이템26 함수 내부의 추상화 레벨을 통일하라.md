## 함수 내부의 추상화 레벨을 통일하라

### 추상화 레벨

* 높은 추상화 레벨로 갈수록 물리 장치로부터 점점 멀어진다
* 높은 레벨일수록 걱정해야 하는 세부적인 내용들이 적어진다
* 높은 레벨일수록 단순함을 얻으나, 제어력을 잃는다

### 추상화 레벨 통일

* 코드도 추상화 계층처럼 함수를 통해 구현할 수 있다
    * 컴퓨터 과학이 높은 레벨과 낮은 레벨을 확실하게 구분하고 있는 것처럼, 함수도 높은 레벨과 낮은 레벨을 구분하여 사용해야 한다는 원친이 있다
    * 이를 추상화 레벨 통일 원칙(Single Level of Abstraction) 원칙이라고 한다
    ```kotlin
    class CoffeeMachine {
        fun makeCoffee() {
            // 해당 함수 하나로 커피 생성을 모두 처리한다면, 코드 라인이 엄청나게 길어질 수 있고, 여러가지 책임을 담당하게 된다
            // 하나의 함수에 모든 로직이 존재한다면, 해당 로직을 읽고 이해하는 것은 거의 불가능에 가깝다
        }
        
        fun makeCoffee() {
            boilWater()
            brewCoffee()
            pourCoffee()
            prouMilk()
            // 위와 같이 함수를 계층처럼 나누어서 사용하면, 해당 함수가 담당하는 역할은 함수 내부에서만
            // 확인할 수 있고, 메서드 이름만으로 어떤 역할을 하는지 예상할 수 있고
            // 특정 로직을 수정 또는 추가해야 할 경우 쉽게 찾아서 수정이 가능하다
        }
    }
    ```
* 함수는 간단하고 작아야 하며, 최소한의 책임만을 가져야 한다라는 일반적인 규칙이 있다
* 어떤 함수가 다른 함수보다 복잡하다면, 일부분을 추출해서 추상화하는 것이 좋다
* 이런 형태로 함수를 추출하면, 재사용과 테스트가 쉬워진다

### 프로그램 아키텍처의 추상 레벨

* 추상화 계층이라는 개념은 함수보다 높은 레벨에도 적용할 수 있다
* 추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻기 위함이다
    * 이는 문제 중심으로 프로그래밍을 한다는 의미이다
* 이러한 개념은 모듈 시스템을 설계할 때도 중요하다
* 모듈을 분리하면 계층 고유의 요소를 숨길 수 있다
    * 낮은 레벨: 입력과 출력을 나타내는 프론트엔드의 뷰, 백엔드의 HTTP 요청 처리 등
    * 높은 레벨: 비즈니스 로직
* 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도 일관적인 관점을 얻을 수 있다

## 정리

* 별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념이다
    * 이는 knowledge 를 체계화하고 서브시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻게 한다
* 함수, 클래스, 모듈 등의 다양한 방식을 통해 추상화를 분리한다
    * 각각의 레이어가 너무 커지지 않는 것이 좋다
    * 작고 최소한의 책임만 가지는 함수가 이해하기 쉽다
* 추상화 레벨은 구쳊거인 동작, 프로세서, 입출력과 가까울수록 낮을 레벨이라고 표현한다
* 낮은 추상화 계층에서는 높은 계층에서 사용하는 요소(API) 를 만든다
