## 문서로 규약을 정의하라

```kotlin
/**
 * Universal way for the project th display a short message to a user
 * @param message The text that should be shown to the user
 * @param length How long to display the message.
 */
fun Context.showMessage(
    message: String,
    length: MessageLength = MessageLength.LONG
) {
    ...
}
```

* 위와 같이 별도의 주석이 없다면, 해당 함수의 동작을 착각할 수 있다
    * 토스트가 아닌 다른 타입으로도 메시지를 출력하고자 의도를 하였으나, 토스트로 메시지가 출력된다와 같은 착각을 할 수 있다
* 해당 함수가 무엇을 하는지 명확하게 설명을 하고 싶다면, KDoc 주석을 붙여 주는 것이 좋다
* 일반적으로 대부분의 함수와 클래스는 이름만으로 예측할 수 없는 세부 사항들을 가지고 있다
    * `powerset` 이라는 의미는 '멱집합' 이며, 이를 모르는 사람이 있을 수 있으므로 추가적인 설명이 있으면 좋다
* 일반적인 문제는 행위가 문서화되지 않고, 요소의 이름이 명확하지 않다면 이를 사용하는 사용자는 목표로 했던 추상화가 아닌 현재 구현에만 의존하게 된다
    * 이러한 문제는 예상되는 행위를 문서로 설명함으로 해결할 수 있다
    
### 규약

* 어떠한 행위를 설명하면, 사용자는 이를 일종의 약속으로 취급하고 이를 기반으로 자유롭게 생각하던 예측을 조정한다
    * 이와같이 예측되는 행위를 요소의 규약이라고 부른다
* 규약이 적절하게 정의되어 있다면, 클래스를 만든 사람은 클래스가 어떻게 사용될지 걱정하지 않아도 된다
* 또한, 규약이 정해져 있다면 클래스를 사용하는 사용자도 클래스가 내부적으로 어떻게 구현되어 있는지 걱정하지 않아도 된다
* 결론적으로 규약이 정해져 있으므로써, 클래스를 만드는 사람과 사용하는 사람 모두 정의된 규약에 따라 독립적으로 작업할 수 있다
* 반대로 규약이 정해지지 않았다면, 만든 사람은 사용자가 어떻게 사용할지 걱정해야 하고 사용자도 내부 구현을 알아야 하는 등의 문제가 발생한다

#### 규약 정의하기

* 규약을 정의하는 대표적인 방법
    * 이름
        * 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할 수 있다
    * 주석과 문서
        * 필요한 모든 규약을 적을 수 있는 강력한 방법
    * 타입
        * 타입은 객체에 대한 많은 것을 알려준다
        * 어떤 함수의 선언에 있는 리턴 타입과 아규먼트 타입은 굉장히 큰 의미가 있다
        * 자주 사용되는 타입은 예측이 가능하지만, 일부 타입은 문서에 추가로 설명이 필요하다

### 주석은 써야 할까?

* 초기에는 '문학적 프로그래밍' 이라는 주석으로 모든 것을 설명하는 방식이 유행이었다가, 최근에는 클린 코드의 코드를 읽어서 이해할 수 있는 형태로 작성하는 방식으로 변화되었다
* 언제나 극단적인 것은 좋지 않으며, 코드만 읽어도 어느정도 알수 있는 코드는 중요하지만 주석도 함께 활용하여 더 많은 내용의 규약을 설명하는 형태가 좋을 수 있다

```kotlin
fun List<Int>.product() = fold(1) { acc, i -> acc * i }
// 리스트의 모든 숫자를 곱한다
```

* 위와 같은 형태의 주석은 이미 `product` 자체가 곱셈이라는 수학적 개념을 나타내므로, 불필요한 주석이다

```kotlin
fun update() {
    // 사용자를 업데이트한다
    for (user in Uses) {
        user.update()
    }
    // 책을 업데이트한다
    for (book in books) {
        updateBook(book)
    }
}
// 위와 같은 주석보다는
fun update() {
    updateUsers()
    updateBooks()
}

private fun updateBooks() {
    for (book in books) {
        updateBook(book)
    }
}
private fun updateUsers() {
    for (user in users) {
        user.update()
    }
}
// 위와 같이 별도의 메서드로 추출하여 주석 없이도 코드만으로 읽혀지는 구현이 가능하다
```

* 코틀린 표준 라이브러리의 모든 public 함수들은 주석을 통해 규약을 잘 정리해주었으며, 이로써 사용자에게 자유를 준다

```kotlin

/**
 * Returns an empty read-only list.  The returned list is serializable (JVM).
 * @sample samples.collections.Collections.Lists.emptyReadOnlyList
 */
@kotlin.internal.InlineOnly
public inline fun <T> listOf(): List<T> = emptyList()
```

### [KDoc](https://kotlinlang.org/docs/kotlin-doc.html) 형식

* 주석으로 함수를 문서화할 때 사용되느 공식적인 형식을 KDoc 이라고 한다
    * 모든 KDoc 주석은 `/**` 으로 시작해서 `*/` 으로 끝난다
    * 그 외의 모든 줄은 일반적으로 `*` 로 시작한다
    * 설명은 KDoc 마크다운이라는 형식으로 작성한다
* KDoc 주석의 구조
```kotlin
/**
 * 첫 번째 부분은 요소에 대한 요약 설명
 * 두 번째 부분은 상세 설명
 * 이어지는 줄은 모두 태그로 시작하며, 이러한 태그는 추가적인 설명을 위해 사용된다
 */
```

* 사용할 수 있는 태그
    * `@param <name>`: 함수 파라미터 또는 클래스/프로퍼티/함수 타입 파라미터
    * `@return`: 함수의 리턴 값
    * `@constructor`: 클래스의 기본 생성자
    * `@receiver`: 확장 함수의 리시버
    * `@property <name>`: 명확한 이름을 가지고 있는 클래스의 프로퍼티를 나타내며, 기본 생성자에 정의된 프로퍼티에 사용한다
    * `@throw <class>, @exception <class>`: 메서드 내부에서 발생할 수 있는 예외
    * `@sample <identifier>`: 정규화된 형식 이름을 사용해서 함수의 사용 예를 문서화
    * `@see <identifer>` 특정한 클래스 또는 메서드에 대한 링크를 추가
    * `@author`: 요소의 작성자
    * `@since`: 요소의 버전 지정
    * `@supress` 이를 지정하면 만들어지는 문서에서 해당 요소가 제외되며, 외부에서 사용할 수 있지만 공식 API 에 포함할 필요없는 요소에 지정
* 설명과 태그를 설명하는 텍스트 모두 요소, 구체 클래스, 메서드, 프로퍼티, 파라미터를 연결할 수 있다
* 관련된 요소 등에 링크를 걸 때는 대괄호를 사용할 수 있고, 링크 대상에 대한 추가 설명을 입력하고 싶으면 대괄호를 두번 연속해서 사용한다
* 이러한 태그들은 모두 코틀린 무서 생성 도구에서 사용되며, 공식적인 코틀린 문서 생성 도구는 Dokka 이다

### 타입 시스템과 예측

* 타입 계층은 객체와 관련된 중요한 정보이며, 인터페이스는 구현해야 한다고 약속한 메서드 목록 이상의 의미를 가진다
* 클래스와 인터페이스에도 여러가지 예측이 들어간다
    * 클래스가 어떠한 동작을 할 것이라 예측되면, 서브클래스도 이를 보장해야 한다
    * 이를 리스코프 치환 원칙이라고 한다
        * 이 원칙은 객체 지향 프로그래밍에서 굉장히 중요하다
        * S 가 T 의 서브타입이라면, 별도의 변경 없이도 T 타입 객체를 S 타입 객체로 대체할 수 있어야 한다
        * 클래스가 어떻게 동작할 거라는 예측 자체에 문제가 있으면, 이 클래스와 관련된 다양한 상속 문제가 발생할 수 있다
* 사용자가 클래스의 동작을 확실하게 예측할 수 있게 하려면, 공개 함수에 대한 규약을 잘 지정해야 한다
    * 인터페이스를 활용하여 이러한 규약을 더 잘 지정할 수 있다
    
```kotlin
interface Car {
    /**
     * 이러한 주석을 통해서 각각의 메서드와 인자값이 어떤 역할로 어떻게 동작할지 설명을
     * 문서화로 사용하는 사용자에게 전달이 가능하다
     */
    fun setWheelPosition(angle: Float)

    /**
     * 이러한 설명을 통해, 규약을 정함으로써 사용자는 해당 클래스에 대한 예측을 쉽게할 수 있다
     */
    fun setBreakPedal(pressure: Double)

    /**
     * 이러한 설명과 규약은 인터페이스를 유용하게 만든다
     */
    fun setGasPedal(pressure: Double)
}

class GasolineCar: Car {}
class GasCar: Car {}
class ElectricCar: Car {}
```

### 조금씩 달라지는 세부 사항

* 규현의 세부적인 내용은 항상 조금씩 다르다
* 구현의 세부 사항을 항상 달라질 수 있지만, 최대한 많이 보호하는 것이 좋다
    * 일반적으로 캡슐화를 통해 이를 보호한다
    * 캡슐화가 많이 적용될수록, 사용자가 구현에 신경을 많이 쓸 필요가 없어지므로, 더 많은 자유를 가지게 된다

## 정리

* 규약을 잘 정의해야 한다
    * 규약은 이름, 문서, 주석, 타입을 통해 구현할 수 있다
    * 규약은 사용자가 객체를 사용하는 방법을 쉽게 이해하는 등 요소를 쉽게 예측할 수 있게 해준다
    * 규약은 요소가 현재 어떻게 동작하고, 앞으로 어떻게 동작할지 사용자에게 전달해 준다
    * 이를 기반으로 사용자는 요소를 확실하게 사용할 수 있고, 규약에 없는 부분을 변경할 수 있는 자유를 얻는다
