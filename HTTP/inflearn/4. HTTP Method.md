### API URI 고민

* 가장 중요한건 **리소 식별**이다
* 리소스란, 말 그대로 자원 그 개념 자체이다
    * 예를들어 회원 조회/수정/삭제에서 회원이 리소스이다
* 리소스 식별은 조회/수정/삭제를 배제한 개념을 식별하면 된다
    * 즉, 위의 회원 조회/수정/삭제에서 회원이라는 리소스만 식별하면 된다
    * 이러한 회원 리소스를 URI 에 매핑한다
    
### API URI 설계

* 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용을 권장한다
    * **회원** 목록 조회: /members
    * **회원** 조회: /members/{id}
    * **회원** 등록: /members/{id}
    * **회원** 수정: /members/{id}
    * **회원** 삭제: /members/{id}
* 하지만 리소스만으로 행위에 대해서는 구분을 할 수 없다

### 리소스와 행위를 분리

* 가장 중요한 것은 리소스를 식별하는 것이며, URI 는 리소스만 식별하면 된다
* 리소스와 해당 리소스를 대상으로 하는 행위를 분리한다
    * 리소스: 회원
    * 행위: 조회/등록/수정/삭제

### HTTP 메서드 종류

* GET: 리소스 조회
* POST: 요청 데이터 처리를 하며, 주로 등록에 사용된다
* PUT: 리소스를 대체에 쓰이며, 해당 리소스가 없으면 생성
* PATCH: 리소스 부분 변경할 때 사용
* DELETE: 리소스 삭제할 떄 사용
* HEAD: GET 과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환할 때 사용
* OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명(주로 CORS 에서 사용)
* CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
* TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

#### GET

* 리소스를 조회
* 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링) 를 통해서 전달
* 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않는다

#### POST

* 스펙: 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청한다
    * HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로스에 제공
    * 게시판, 뉴스 그룹, 블로그 등과 같은 유사한 기사 그룹에 메시지 게시
    * 서버가 아직 식별하지 않은 새 리소스 생성
    * 기존 자원에 데이터 추가
* 메시지 바디를 통해 서버로 요청 데이터를 전달한다
* 서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다
* 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용한다
* 결론은 리소스 URI 에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다
    1. 새 리소스 생성(등록)
    1. 요청 데이터 처리 (POST 의 결과로 새로운 리소스가 생성되지 않을 수 있음)
    1. 다른 메서드로 처리하기 애매한 경우

#### PUT

* 리소스를 대체
    * 리소스가 있으면 **완전히** 대체
    * 리소스가 없으면 생성
* 클라이언트가 리소스를 식별
    * POST 와 다르게 클라이언트가 리소스 위치를 알고 URI 지정

#### PATCH

* 리소스 부분 변경
* PATCH 를 지원 안하는 서버도 존재를 하며, 이때는 POST 를 사용하면 된다

#### DELETE

* 리소스 제거

### HTTP 메서드의 속성

* 안전(Safe Methods)
* 멱등(Idempotent Methods)
* 캐시가능(Cacheable Methods)

#### 안전

* 호출해도 리소스를 변경하지 않는다
    * 많은 조회로 인한 에러, Timeout 등의 오류는 고려하지 않고 리소스에 대해서만 고려한다

#### 멱등

* f(f(x)) = f(x)
* 한 번 호출하는 것과 그 이상 여러번 호출하는 것의 결과는 같다
* 멱등 메서드
    * GET: 몇번 조회하든 같은 결과가 조회된다
        * 재요청 결과가 다른 곳에 리소스를 변경한 결과 등과 같이 외부 요인으로 변경되는 것 까지는 고려하지 않는다
    * PUT: 결과를 대체하므로, 같은 요청을 여러번 해도 최종 결과는 같다
    * DELETE: 결과를 삭제하므로, 같은 요청을 여러번 해도 삭제된 결과는 같다
* POST: 두 번 호출하면 중복 문제 등 어떠한 문제가 발생할 수 있으므로 멱등이 아니다
* 자동 복구 메커니즘, Timeout 등과 같은 상황에서 활용할 수 있다

#### 캐시가능

* GET/HEAD/POST/PATCH 등은 캐시가 가능하다
    * 실제로는 GET/HEAD 정도만 캐시로 사용한다
    * POST/PATCH 는 본문 내용까지 캐시 키로 고려해야 하므로 구현이 쉽지 않다