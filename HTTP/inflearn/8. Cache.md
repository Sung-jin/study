### 캐시

* 캐시를 적용하면 캐싱된 데이터를 다시 요청할 경우 네트워크를 타지 않고 리소스를 받을 수 있다
    * 브라우저 로딩 속도가 빨라진다
* `cache-control: max-age=60` 와 같이 유효 시간을 정할 수 있다
    * 해당 시간이 지난 리소스를 요청하면, 다시 서버에 요청한다
  
### 검증 헤더와 조건부 요청

* 캐시 만료후에도 서버에서 데이터를 변경되지 않았을 수 있다
    * 변경되지 않았다면 서버에서 데이터를 전송하는 대신 캐싱된 데이터를 재사용할 수 있다
    * 단, 클라이언트와 서버간의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다

#### 검증헤더

* `Last-Modified: xxx` 와 같은 형태로 검증용 헤더를 추가하여 변경되었는지 확인할 수 있다
* 검증헤더 추가 후 요청 흐름
    1. 캐시 만료시 `if-modified-since: xxx` 와 같은 형태로 서버에 요청하여 변경되었는지 호출
    1. 서버에서 해당 리소스의 마지막 시간과, 요청온 시간을 검증하여 변경되었는지 확인
    1. 변경이 안되었다면 304 Not Modified 와 만료시간, 검증헤더를 전송 (HTTP Body 는 존재하지 않는다)
    1. 변경이 된 경우 200 OK 와 실제 데이터 (HTTP Body) 와 메타 헤더와 함께 전송한다
  
#### Last-Modified, If-Modified-Since 단점

* 1초 미만 단위로 캐시 조정이 불가능
* 날짜 기반의 로직 사용
* 데이터를 수정해서 날짜가 다르지만 같은 데이터를 수정해서 데이터가 똑같은 경우에도 변경된 것으로 판단함
* 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 사용 불가능함

#### ETag, If-None-Match

* Entity Tag
* 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다
* 데이터가 변경되면 해당 이름을 변경한다
* 데이터 변경 여부는 해당 태그의 값을 캐싱된 값과 비교하여 체크한다
* 캐시 제어 로직을 서버에서 완전히 관리한다
    * 클라이언트는 단순히 해당 값을 서버에 제공을 하면, 서버에서 변경되었는지 체크를 진행하고 그 결과를 반환한다
  
### Cache-Control

* 캐시 지시어
* Cache-Control: xxx
    * max-age: 캐시 유효시간(초 단위)
    * no-cache: 데이터는 캐시해도 되지만 항상 origin 서버에 검증하고 사용
    * no-store: 데이터에 민감한 정보가 있으므로 저장하면 안됨
    * must-revalidate: 캐시 만료후 최초 조회시 origin 서버에 검증해야 한다 (실패시 504 Gateway Timeout)
    * public: 응답이 public 캐시에 저장되어도 됨
    * private: 응답이 해당 사용자만을 위한 것이며, private 캐시에 젖아해야 함 (기본값)
    * s-maxage: 프록시 캐시에만 적용되는 max-age
    * Age: 60 (HTTP 헤더): 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간 (초)
  
### Pragma

* 캐시 제어 (하위 호환)
* Pragma: no-cache
* HTTP 1.0 하위 호환

### Expires

* 캐시 만료일 지정 (하위 호환)
* `expires: xxx`
* 캐시 만료일을 정확한 날짜로 지정
* HTTP 1.0 부터 사용가능하지만, 지금은 더 유연한 Cache-Control: max-age 를 권장한다
    * Cache-Control: max-age 와 함께 사용되면 expires 는 무시된다

### 검증 헤더와 조건부 요청 헤더

* 검증 헤더
    * ETag, Last-Modified
* 조건부 요청 헤더
    * If-Match, If-None-Match (ETag 사용)
    * If-Modified-Since, If-Unmodified-Since (Last-Modified 에서 사용)

### 프록시 캐시

* 해외 사이트 등 아주 먼 거리의 서버에 리소스르 요청할 경우 응답시간이 오래 걸린다
* 이때, 프록시 서버를 통해 요청을 하면 더 빠르게 응답을 받을 수 있다
    1. 클라이언트가 리소스를 요청
    1. 프록시 서버에서 해당 리소스를 확인 후 있으면 해당 리소스 응답 (프록시 서버는 origin 서버보다 가까운 곳에 위치함)
        * 요청시 응답을 하는 경우도 있고, 프록시 서버에 미리 업데이트를 하는 경우도 있음
    1. 해당 리소스가 없다면 origin 서버에 해당 리소스를 요청 후 응답 데이터를 캐싱 및 클라이언트에 응답
    1. 프록시 서버의 캐싱 전략에 따라 만료 주기 등등이 다름

### 확실한 캐시 무효화 응답

* 캐싱 관련된 헤더를 넣지 않더라도 브라우저마다 임의로 캐싱을 하는 경우가 존재한다
* 이러한 상황에서 아래와 같은 값을 다 넣어야 확실하게 캐시를 무효화 할 수 있다
    * `Cache-Control: no-cache, no-store, must-revalidate`
    * `Paragma: no-cache` (HTTP 1.0 하위 호환)